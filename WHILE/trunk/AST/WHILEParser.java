// Generated from WHILE.parser

 package AST;
 import java.io.*;
 import utility.LabelUtility;
 
import java.util.ArrayList;
import beaver.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.4
 * from the grammar specification "WHILEParser.beaver".
 */
public class WHILEParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short IF = 1;
		static public final short THEN = 2;
		static public final short ELSE = 3;
		static public final short LBRACE = 4;
		static public final short RBRACE = 5;
		static public final short IDENTIFIER = 6;
		static public final short ASSIGN = 7;
		static public final short WHILE = 8;
		static public final short DO = 9;
		static public final short LPAREN = 10;
		static public final short RPAREN = 11;
		static public final short READ = 12;
		static public final short SANITIZE = 13;
		static public final short SEMICOLON = 14;
		static public final short SKIP = 15;
		static public final short NUMBER = 16;
		static public final short TRUE = 17;
		static public final short FALSE = 18;
		static public final short NOT = 19;
		static public final short OPMUL = 20;
		static public final short OPPLUS = 21;
		static public final short OPMINUS = 22;
		static public final short OPRELATIONAL = 23;
		static public final short AND = 24;
		static public final short OR = 25;
		static public final short ASSERT = 26;
		static public final short PRINT = 27;

		static public final String[] NAMES = {
			"EOF",
			"IF",
			"THEN",
			"ELSE",
			"LBRACE",
			"RBRACE",
			"IDENTIFIER",
			"ASSIGN",
			"WHILE",
			"DO",
			"LPAREN",
			"RPAREN",
			"READ",
			"SANITIZE",
			"SEMICOLON",
			"SKIP",
			"NUMBER",
			"TRUE",
			"FALSE",
			"NOT",
			"OPMUL",
			"OPPLUS",
			"OPMINUS",
			"OPRELATIONAL",
			"AND",
			"OR",
			"ASSERT",
			"PRINT"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pbLKjF4r4OFRT32wLI1AhGsWArFCG72hvrQuo9R8nhV8GO4rrZ8Z7freskJTouyXyODyQ" +
		"DEtTkZ3kZGdcLygvFk9xxpPtEj8c4X1WNpfVptU#US#utDtCxqr23Ne2347CNkj7CCQuNz2" +
		"UjFGQxq8bMSbuiwas4JTO$YKNq4VM8C4SDWpRzYweVPSJ8bD67EfpLPJt5kWNTpAP$3zA62" +
		"SGwzbDTvwhFnBh#mJg90UQZP1mSD4mWrkZwhjVqDuvVEKu668VC5yC4OfNCXbx58HoclefZ" +
		"n0bXJi5UzFYn8ioALLQyscFSEX3BmYnRPTchFSQj0r4IfcILabTxZ5ojkbI99L6Nh7$9gpt" +
		"6hGDH5APebQ9NUupjNwp4lAZprZylQBIC#ul8y1Un6rdaz3pPVZ4wH0DnH6RzE8wJv7fzJi" +
		"yPZhaNGpZDqJ3mik5O5qnVNT1peXVq31cusOmkR6uIRLhcq#AQqTDwLch9IEXPKoCbsQoOn" +
		"XxiHJiwa12NqHBs6QGg6e8kg#tSjSzg$ZFSRlS3LlDN#jhW5jhm5jgPFseXlgSPXCbd#IP6" +
		"#OR6U6P0t38vCecAEqa$w0xpj4sEScsCNUECUibPijN#9DcmtBEB$Z3zfhFNFyQgsjyjFP8" +
		"2rvyb6sSTbxtM#fEo4tU5wq$AJepRtBdM7xVxpr1tznyHTqJRgzelJDWgKI8cLLph$yNFRx" +
		"Ru0xy8tw$4LqVm#Q51Peh$8arykiq1BYHSc5oAxqRDFWmd7jCtRFgQUtCUCtkndgerrbFPh" +
		"UobQWLFrTrzex#2tviMjA9DzcNcZTwfix8Qwu3BQZjtfQtcFyDjTdTNKlDN$atjN5xh3SHK" +
		"5yyYgGQeTAhRw53ZweAQK2CgeXxgJVM8vpI8YxY6U#ef7gjd$Fu$LwFg5bxZlNg9adgbXd4" +
		"Pe#ejhk0gxkCEhgiF6C44Rge2$niUO0nvt5Lhk8HntdCghz6UryoEv3Av1M9IPYcYtbHkO2" +
		"YlrHD$JcQ0oBYrUi7wF763zHkEOnpV#LxrKLRyYwkJtrR5Rux3IX4Elua6oY92rF5CL0r2X" +
		"CFJKeJ34rE48#XXtSCnnp77CSqnBJr3LUZx3Se57Qm=");
 // Generated from WHILE.parser

  /** Syntax error exceptions. */
  public class ParseException extends RuntimeException {
  	public ParseException(String msg) { super(msg); }
  }
  
  /** Error handling adapter for using Beaver from JastAdd. */
  class Events extends Parser.Events {
    public void syntaxError(Symbol token) {
      StringBuffer s = new StringBuffer();
      s.append("line: " + token.getLine(token.getStart()) + " char: " + token.getColumn(token.getStart()) + "\n");
      s.append("  *** Syntactic error: unexpected token " + Terminals.NAMES[token.getId()]);
      throw new ParseException(s.toString());
    }
    public void scannerError(Scanner.Exception e) {
      StringBuffer s = new StringBuffer();
      s.append("line: " + e.line + " char: " + e.column + "\n");
      s.append("  *** Lexical error: " + e.getMessage());
      throw new ParseException(s.toString());
    }
  }

  { LabelUtility.reset(); 
    report = new Events(); // Use error handler in parser
  }
  
  public Program parse(java.io.InputStream is, String fileName) throws java.io.IOException, beaver.Parser.Exception {
     Program prog;
     // errors = new ArrayList();
     try {
       WHILEScanner scanner = new WHILEScanner(new BufferedReader(new InputStreamReader(is)));
       prog = (Program)parse(scanner);
     } catch(ParseException e) {
       // build empty program for failed error recovery
       prog = new Program();
     } catch(Error e) {
       prog = new Program();
       // errors.add(new Problem(null, e.getMessage(), 0, 0, Problem.Severity.ERROR, Problem.Kind.LEXICAL));
     }
     // for(java.util.Iterator iter = errors.iterator(); iter.hasNext(); ) {
     //   Problem p = (Problem)iter.next();
     //   p.setFileName(fileName);
     //   prog.addParseError(p);
     // }
     return prog;
   }
   // protected java.util.Collection errors = new ArrayList();

	public WHILEParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // goal = block.block
			{
					final Symbol _symbol_block = _symbols[offset + 1];
					final S block = (S) _symbol_block.value;
					  return new Program(block);
			}
			case 1: // block = LBRACE.LBRACE blockStmtList.blockStmtList RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_blockStmtList = _symbols[offset + 2];
					final List blockStmtList = (List) _symbol_blockStmtList.value;
					final Symbol RBRACE = _symbols[offset + 3];
					  return new CompoundS(blockStmtList);
			}
			case 2: // blockStmtList = stmt.stmt
			{
					final Symbol _symbol_stmt = _symbols[offset + 1];
					final S stmt = (S) _symbol_stmt.value;
					  return new List().add(stmt);
			}
			case 3: // blockStmtList = blockStmtList.blockStmtList SEMICOLON.SEMICOLON stmt.stmt
			{
					final Symbol _symbol_blockStmtList = _symbols[offset + 1];
					final List blockStmtList = (List) _symbol_blockStmtList.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					final Symbol _symbol_stmt = _symbols[offset + 3];
					final S stmt = (S) _symbol_stmt.value;
					  return blockStmtList.add(stmt);
			}
			case 4: // stmt = IDENTIFIER.IDENTIFIER ASSIGN.ASSIGN expression.e
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					final Symbol ASSIGN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					  return new AssignS(new NumLabel(LabelUtility.nextLabel()), ((String)IDENTIFIER.value), e);
			}
			case 5: // stmt = SKIP.SKIP
			{
					final Symbol SKIP = _symbols[offset + 1];
					  return new SkipS(new NumLabel(LabelUtility.nextLabel()));
			}
			case 6: // stmt = block.block
			{
					final Symbol _symbol_block = _symbols[offset + 1];
					final S block = (S) _symbol_block.value;
					  return block;
			}
			case 7: // stmt = IF.IF expression.be THEN.THEN block.b ELSE.ELSE block.c
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol _symbol_be = _symbols[offset + 2];
					final Expr be = (Expr) _symbol_be.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final S b = (S) _symbol_b.value;
					final Symbol ELSE = _symbols[offset + 5];
					final Symbol _symbol_c = _symbols[offset + 6];
					final S c = (S) _symbol_c.value;
					  return new IfS(new LabeledExpr(new NumLabel(LabelUtility.nextLabel()), be), b, c);
			}
			case 8: // stmt = WHILE.WHILE expression.be DO.DO block.block
			{
					final Symbol WHILE = _symbols[offset + 1];
					final Symbol _symbol_be = _symbols[offset + 2];
					final Expr be = (Expr) _symbol_be.value;
					final Symbol DO = _symbols[offset + 3];
					final Symbol _symbol_block = _symbols[offset + 4];
					final S block = (S) _symbol_block.value;
					  return new WhileS(new LabeledExpr(new NumLabel(LabelUtility.nextLabel()), be), block);
			}
			case 9: // primary = IDENTIFIER.IDENTIFIER
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					  return new VarRefExpr(((String)IDENTIFIER.value));
			}
			case 10: // primary = NUMBER.NUMBER
			{
					final Symbol NUMBER = _symbols[offset + 1];
					  return new NumLitExpr(((String)NUMBER.value));
			}
			case 11: // primary = TRUE.TRUE
			{
					final Symbol TRUE = _symbols[offset + 1];
					  return new BoolLitExpr(((String)TRUE.value));
			}
			case 12: // primary = FALSE.FALSE
			{
					final Symbol FALSE = _symbols[offset + 1];
					  return new BoolLitExpr(((String)FALSE.value));
			}
			case 13: // primary = NOT.NOT primary.e
			{
					final Symbol NOT = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					  return new NotExpr(e);
			}
			case 14: // primary = LPAREN.LPAREN expression.e RPAREN.RPAREN
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 3];
					  return e;
			}
			case 15: // factor = primary.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					  return p;
			}
			case 16: // factor = factor.l OPMUL.OPMUL primary.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final Expr l = (Expr) _symbol_l.value;
					final Symbol OPMUL = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final Expr r = (Expr) _symbol_r.value;
					  return new ABinaryExpr(l, new Op_a(((String)OPMUL.value)), r);
			}
			case 17: // aexpression = factor.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final Expr f = (Expr) _symbol_f.value;
					  return f;
			}
			case 18: // aexpression = aexpression.l OPPLUS.OPPLUS factor.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final Expr l = (Expr) _symbol_l.value;
					final Symbol OPPLUS = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final Expr r = (Expr) _symbol_r.value;
					  return new ABinaryExpr(l, new Op_a(((String)OPPLUS.value)), r);
			}
			case 19: // aexpression = aexpression.l OPMINUS.OPMINUS factor.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final Expr l = (Expr) _symbol_l.value;
					final Symbol OPMINUS = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final Expr r = (Expr) _symbol_r.value;
					  return new ABinaryExpr(l, new Op_a(((String)OPMINUS.value)), r);
			}
			case 21: // relexp = aexpression.l OPRELATIONAL.OPRELATIONAL aexpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final Expr l = (Expr) _symbol_l.value;
					final Symbol OPRELATIONAL = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final Expr r = (Expr) _symbol_r.value;
					  return new RelExpr(l, new Op_r(((String)OPRELATIONAL.value)), r);
			}
			case 22: // conj = relexp.re
			{
					final Symbol _symbol_re = _symbols[offset + 1];
					final Expr re = (Expr) _symbol_re.value;
					  return re;
			}
			case 23: // conj = conj.l AND.AND relexp.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final Expr l = (Expr) _symbol_l.value;
					final Symbol AND = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final Expr r = (Expr) _symbol_r.value;
					  return new LogicExpr(l, new Op_b(((String)AND.value)), r);
			}
			case 24: // expression = conj.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					  return c;
			}
			case 25: // expression = expression.l OR.OR conj.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final Expr l = (Expr) _symbol_l.value;
					final Symbol OR = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final Expr r = (Expr) _symbol_r.value;
					  return new LogicExpr(l, new Op_b(((String)OR.value)), r);
			}
			case 26: // stmt = ASSERT.ASSERT expression.be
			{
					final Symbol ASSERT = _symbols[offset + 1];
					final Symbol _symbol_be = _symbols[offset + 2];
					final Expr be = (Expr) _symbol_be.value;
					  return new AssertS(new LabeledExpr(new NumLabel(LabelUtility.nextLabel()), be));
			}
			case 27: // stmt = READ.READ IDENTIFIER.IDENTIFIER
			{
					final Symbol READ = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					  return new ReadS(new NumLabel(LabelUtility.nextLabel()), ((String)IDENTIFIER.value));
			}
			case 28: // stmt = SANITIZE.SANITIZE IDENTIFIER.IDENTIFIER
			{
					final Symbol SANITIZE = _symbols[offset + 1];
					final Symbol IDENTIFIER = _symbols[offset + 2];
					  return new SanitizeS(new NumLabel(LabelUtility.nextLabel()), ((String)IDENTIFIER.value));
			}
			case 29: // stmt = PRINT.PRINT expression.e
			{
					final Symbol PRINT = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					  return new PrintS(new NumLabel(LabelUtility.nextLabel()), e);
			}
			case 20: // relexp = aexpression.aexpression
			{
				return _symbols[offset + 1];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
