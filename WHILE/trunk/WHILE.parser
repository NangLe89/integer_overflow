%header {:
 package AST;
 import java.io.*;
 import utility.LabelUtility;
 :};
  
%embed {:
  /** Syntax error exceptions. */
  public class ParseException extends RuntimeException {
  	public ParseException(String msg) { super(msg); }
  }
  
  /** Error handling adapter for using Beaver from JastAdd. */
  class Events extends Parser.Events {
    public void syntaxError(Symbol token) {
      StringBuffer s = new StringBuffer();
      s.append("line: " + token.getLine(token.getStart()) + " char: " + token.getColumn(token.getStart()) + "\n");
      s.append("  *** Syntactic error: unexpected token " + Terminals.NAMES[token.getId()]);
      throw new ParseException(s.toString());
    }
    public void scannerError(Scanner.Exception e) {
      StringBuffer s = new StringBuffer();
      s.append("line: " + e.line + " char: " + e.column + "\n");
      s.append("  *** Lexical error: " + e.getMessage());
      throw new ParseException(s.toString());
    }
  }

  { LabelUtility.reset(); 
    report = new Events(); // Use error handler in parser
  }
  
  public Program parse(java.io.InputStream is, String fileName) throws java.io.IOException, beaver.Parser.Exception {
     Program prog;
     // errors = new ArrayList();
     try {
       WHILEScanner scanner = new WHILEScanner(new BufferedReader(new InputStreamReader(is)));
       prog = (Program)parse(scanner);
     } catch(ParseException e) {
       // build empty program for failed error recovery
       prog = new Program();
     } catch(Error e) {
       prog = new Program();
       // errors.add(new Problem(null, e.getMessage(), 0, 0, Problem.Severity.ERROR, Problem.Kind.LEXICAL));
     }
     // for(java.util.Iterator iter = errors.iterator(); iter.hasNext(); ) {
     //   Problem p = (Problem)iter.next();
     //   p.setFileName(fileName);
     //   prog.addParseError(p);
     // }
     return prog;
   }
   // protected java.util.Collection errors = new ArrayList();
  
:};

/* JastAdd doesn't seem to process the following precedence decls, so it's commented out!
// precedence (highest first)
%right NOT;               
%left OPMUL;              
%left OPPLUS, OPMINUS;            
%nonassoc OPRELATIONAL;  
%left AND;               
%left OR;                
*/

Program goal =
  block                            {: return new Program(block); :}
  ;

S block =
    LBRACE blockStmtList RBRACE   {: return new CompoundS(blockStmtList); :}
  ;

List blockStmtList =
    stmt                          {: return new List().add(stmt); :}
  | blockStmtList SEMICOLON stmt  {: return blockStmtList.add(stmt); :}
  ;

S stmt =
    IDENTIFIER ASSIGN expression.e   {: return new AssignS(new NumLabel(LabelUtility.nextLabel()), IDENTIFIER, e); :}
  | SKIP                             {: return new SkipS(new NumLabel(LabelUtility.nextLabel())); :}
  | block                            {: return block; :}
  | IF expression.be THEN block.b ELSE block.c  {: return new IfS(new LabeledExpr(new NumLabel(LabelUtility.nextLabel()), be), b, c); :}
  | WHILE expression.be DO block     {: return new WhileS(new LabeledExpr(new NumLabel(LabelUtility.nextLabel()), be), block); :}
  ;
   

Expr primary =
       IDENTIFIER               {: return new VarRefExpr(IDENTIFIER); :}
     | NUMBER                   {: return new NumLitExpr(NUMBER); :}
     | TRUE                     {: return new BoolLitExpr(TRUE); :}
     | FALSE                    {: return new BoolLitExpr(FALSE); :}
     | NOT primary.e            {: return new NotExpr(e); :}
     | LPAREN expression.e RPAREN {: return e; :}
     ;
     
Expr factor =
     primary.p                 {: return p; :}
   | factor.l OPMUL primary.r 
                               {: return new ABinaryExpr(l, new Op_a(OPMUL), r); :}
   ;
   
Expr aexpression =
     factor.f                  {: return f; :}
   | aexpression.l OPPLUS factor.r
                               {: return new ABinaryExpr(l, new Op_a(OPPLUS), r); :}
   | aexpression.l OPMINUS factor.r
                               {: return new ABinaryExpr(l, new Op_a(OPMINUS), r); :}
   ;
   
Expr relexp =
       aexpression
     | aexpression.l OPRELATIONAL aexpression.r 
                                {: return new RelExpr(l, new Op_r(OPRELATIONAL), r); :}
     ;

Expr conj =
       relexp.re               {: return re; :}
     | conj.l AND relexp.r 
                               {: return new LogicExpr(l, new Op_b(AND), r); :}
     ;
     
Expr expression = 
       conj.c                  {: return c; :}                         
     | expression.l OR conj.r 
                               {: return new LogicExpr(l, new Op_b(OR), r); :}
     ;
S stmt =
	ASSERT expression.be             {: return new AssertS(new LabeledExpr(new NumLabel(LabelUtility.nextLabel()), be)); :}
    ;S stmt =
       READ IDENTIFIER             {: return new ReadS(new NumLabel(LabelUtility.nextLabel()), IDENTIFIER); :}
     | SANITIZE IDENTIFIER	   {: return new SanitizeS(new NumLabel(LabelUtility.nextLabel()), IDENTIFIER); :}
     | PRINT expression.e          {: return new PrintS(new NumLabel(LabelUtility.nextLabel()), e); :}
     ;
     
