// Control Flow Graph attributes, see Section 2.1 of "Principles of Progarm Analysis"
// by Nielsen, Nielsen, and Hankin (Springer-Verlag, 1999 and 2005).

import java.util.*;
import utility.SetRepUtility;
import utility.FlowGraph;

aspect CFG {

	syn Label S.init();	
	eq AssignS.init() = getLabelAST();
	eq SkipS.init() = getLabelAST();
	eq IfS.init() = getLabeledExpr().getLabelAST();
	eq WhileS.init() = getLabeledExpr().getLabelAST();
	eq CompoundS.init() = getSList(0).init();
	eq AssertS.init() = getLabeledExpr().getLabelAST();
	
	syn Set<Label> Program.finals();
	eq Program.finals() = getS().finals();
	syn Set<Label> S.finals();
	eq AssignS.finals() = SetRepUtility.singleton(getLabelAST());
	eq SkipS.finals() = SetRepUtility.singleton(getLabelAST());
	eq IfS.finals() {
		 Set<Label> ret = getS1().finals();
		 ret.addAll(getS2().finals());
		 return ret;
	   }
	eq WhileS.finals() = SetRepUtility.singleton(getLabeledExpr().getLabelAST());
	eq CompoundS.finals() = getSList(getNumSList()-1).finals();
	eq AssertS.finals() = SetRepUtility.singleton(getLabeledExpr().getLabelAST());
	
	/** Blocks are kinds of control flow graph nodes. */
	public interface Block {
		Set<Label> inFlows();
		Set<Label> outFlows();
		Label getLabelAST();
	}
	// Make S and LabeledExpr be subtypes of Block
	AssignS implements Block;
	SkipS implements Block;
	LabeledExpr implements Block;	
	
	// Set of blocks in a statement
	syn Set<Block> S.blocks();
	eq AssignS.blocks() = SetRepUtility.singleton(this);
	eq SkipS.blocks() = SetRepUtility.singleton(this);
	eq IfS.blocks() {
	     Set<Block> ret = getS1().blocks();
	     ret.addAll(getS2().blocks());
	     ret.add(getLabeledExpr());
	     return ret;
	   }
	eq WhileS.blocks() {
	      Set<Block> ret = getS().blocks();
	      ret.add(getLabeledExpr());
	      return ret;
	   }
	eq CompoundS.blocks() {
	     Set<Block> ret = SetRepUtility.emptySet();
	     for (int i =0; i < getNumSList(); i++) {
	        ret.addAll(getSList(i).blocks());
	     }
	     return ret;
	   }
	 eq AssertS.blocks() = SetRepUtility.singleton(this);
	
	// Set of labels in a statement
	syn Set<Label> S.labels();
	eq AssignS.labels() = SetRepUtility.singleton(getLabelAST());
	eq SkipS.labels() = SetRepUtility.singleton(getLabelAST());
	eq IfS.labels() {
	     Set ret = SetRepUtility.singleton(getLabeledExpr().getLabelAST());
	     ret.addAll(getS1().labels());
	     ret.addAll(getS2().labels());
	     return ret;
	   }
	eq WhileS.labels() {
	     Set ret = SetRepUtility.singleton(getLabeledExpr().getLabelAST());
	     ret.addAll(getS().labels());
	     return ret;
	   }
	eq CompoundS.labels() {
	     Set ret = SetRepUtility.emptySet();
	     for (int i = 0; i < getNumSList(); i++) {
	       ret.addAll(getSList(i).labels());
	     }
	     return ret;
	   }
	 eq AssertS.labels() = SetRepUtility.singleton(getLabeledExpr().getLabelAST());
	
    // the following are needed so that labels can be hashed...
	public boolean NumLabel.equals(Object oth) {
	   if (oth == null || !(oth instanceof NumLabel)) { return false; }
	   NumLabel l = (NumLabel) oth;
	   return getNum().equals(l.getNum());
	}
	public int NumLabel.hashCode() {
	   return getNum().hashCode();
	}
	    
    // Mapping from labels to back to blocks
	inh Block Label.itsBlock();
	eq AssignS.getLabelAST().itsBlock() = this;
	eq SkipS.getLabelAST().itsBlock() = this; 
	eq LabeledExpr.getLabelAST().itsBlock() = this;

	// Flows into a block
	inh Set<Label> S.inFlows();	
	eq Program.getS().inFlows() = SetRepUtility.emptySet();
	eq IfS.getS1().inFlows() {
	    return SetRepUtility.singleton(getLabeledExpr().getLabelAST());
	}
	eq IfS.getS2().inFlows() {
	    return SetRepUtility.singleton(getLabeledExpr().getLabelAST());
	}
	eq WhileS.getS().inFlows() {
	    return SetRepUtility.singleton(getLabeledExpr().getLabelAST());
	}
	eq CompoundS.getSList(int index).inFlows() {
		if (index == 0) {
			return inFlows();
		} else { 
			return getSList(index-1).finals();
		}
	}
	
	inh Set<Label> LabeledExpr.inFlows();
	eq IfS.getLabeledExpr().inFlows() = this.inFlows();
	eq WhileS.getLabeledExpr().inFlows() {
		Set<Label> ins = this.inFlows();
		ins.addAll(getS().finals());
		return ins;
	}
	eq AssertS.getLabeledExpr().inFlows() = this.inFlows();

	// Next statement in a sequence (lexically), null if none.
	// This is a helping attribute for outFlows (below)
	inh S S.next();
	eq CompoundS.getSList(int index).next() {
		if (index == getNumSList()-1) {
			return next();
		} else {
			return getSList(index+1);
		}
	}
	eq Program.getS().next() = null;
	eq IfS.getS1().next() = next();
	eq IfS.getS2().next() = next();
	eq WhileS.getS().next() = this;
	
	// Flows out of a block
	inh Set<Label> S.outFlows();	
	eq Program.getS().outFlows() = SetRepUtility.emptySet();
	eq IfS.getS1().outFlows() {
	    return next() == null ? SetRepUtility.emptySet() 
	    		: SetRepUtility.singleton(next().init());
	}
	eq IfS.getS2().outFlows() {
	    return next() == null ? SetRepUtility.emptySet() 
	    		: SetRepUtility.singleton(next().init());
	}
	eq WhileS.getS().outFlows() {
	    return SetRepUtility.singleton(getLabeledExpr().getLabelAST());
	}
	eq CompoundS.getSList(int index).outFlows() {
		if (index == getNumSList()-1) {
			return outFlows();
		} else { 
			return SetRepUtility.singleton(getSList(index+1).init());
		}
	}
	
	inh Set<Label> LabeledExpr.outFlows();
	eq IfS.getLabeledExpr().outFlows() {
	    Set<Label> ret = SetRepUtility.singleton(getS1().init());
	    ret.add(getS2().init());
	    return ret;
	}
	eq WhileS.getLabeledExpr().outFlows() {
		Set<Label> outs = SetRepUtility.singleton(getS().init());
		if (next() != null) { outs.add(next().init()); }
		return outs;
	}
	eq AssertS.getLabeledExpr().outFlows() = this.outFlows();
}
