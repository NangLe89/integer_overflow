// Generated from parser/picoC.parser
package AST;
import AST.*; 
import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "PicoCParser.beaver".
 */
public class PicoCParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short SEMICOLON = 1;
		static public final short PLUSPLUS = 2;
		static public final short MINUSMINUS = 3;
		static public final short IDENTIFIER = 4;
		static public final short INTEGER_LITERAL = 5;
		static public final short LONG_LITERAL = 6;
		static public final short FLOATING_POINT_LITERAL = 7;
		static public final short DOUBLE_LITERAL = 8;
		static public final short CHARACTER_LITERAL = 9;
		static public final short STRING_LITERAL = 10;
		static public final short RPAREN = 11;
		static public final short PLUS = 12;
		static public final short MINUS = 13;
		static public final short COMMA = 14;
		static public final short COLON = 15;
		static public final short QUESTION = 16;
		static public final short OROR = 17;
		static public final short ANDAND = 18;
		static public final short LBRACE = 19;
		static public final short OR = 20;
		static public final short WHILE = 21;
		static public final short FOR = 22;
		static public final short DO = 23;
		static public final short IF = 24;
		static public final short CONTINUE = 25;
		static public final short BREAK = 26;
		static public final short SWITCH = 27;
		static public final short RETURN = 28;
		static public final short BYTE = 29;
		static public final short SHORT = 30;
		static public final short INT = 31;
		static public final short LONG = 32;
		static public final short CHAR = 33;
		static public final short XOR = 34;
		static public final short AND = 35;
		static public final short RBRACE = 36;
		static public final short EQEQ = 37;
		static public final short NOTEQ = 38;
		static public final short COMP = 39;
		static public final short NOT = 40;
		static public final short LT = 41;
		static public final short GT = 42;
		static public final short LTEQ = 43;
		static public final short GTEQ = 44;
		static public final short CASE = 45;
		static public final short DEFAULT = 46;
		static public final short LSHIFT = 47;
		static public final short RSHIFT = 48;
		static public final short ELSE = 49;
		static public final short MULT = 50;
		static public final short DIV = 51;
		static public final short MOD = 52;
		static public final short EQ = 53;
		static public final short MULTEQ = 54;
		static public final short DIVEQ = 55;
		static public final short MODEQ = 56;
		static public final short PLUSEQ = 57;
		static public final short MINUSEQ = 58;
		static public final short LSHIFTEQ = 59;
		static public final short RSHIFTEQ = 60;
		static public final short ANDEQ = 61;
		static public final short XOREQ = 62;
		static public final short OREQ = 63;
		static public final short LPAREN = 64;

		static public final String[] NAMES = {
			"EOF",
			"SEMICOLON",
			"PLUSPLUS",
			"MINUSMINUS",
			"IDENTIFIER",
			"INTEGER_LITERAL",
			"LONG_LITERAL",
			"FLOATING_POINT_LITERAL",
			"DOUBLE_LITERAL",
			"CHARACTER_LITERAL",
			"STRING_LITERAL",
			"RPAREN",
			"PLUS",
			"MINUS",
			"COMMA",
			"COLON",
			"QUESTION",
			"OROR",
			"ANDAND",
			"LBRACE",
			"OR",
			"WHILE",
			"FOR",
			"DO",
			"IF",
			"CONTINUE",
			"BREAK",
			"SWITCH",
			"RETURN",
			"BYTE",
			"SHORT",
			"INT",
			"LONG",
			"CHAR",
			"XOR",
			"AND",
			"RBRACE",
			"EQEQ",
			"NOTEQ",
			"COMP",
			"NOT",
			"LT",
			"GT",
			"LTEQ",
			"GTEQ",
			"CASE",
			"DEFAULT",
			"LSHIFT",
			"RSHIFT",
			"ELSE",
			"MULT",
			"DIV",
			"MOD",
			"EQ",
			"MULTEQ",
			"DIVEQ",
			"MODEQ",
			"PLUSEQ",
			"MINUSEQ",
			"LSHIFTEQ",
			"RSHIFTEQ",
			"ANDEQ",
			"XOREQ",
			"OREQ",
			"LPAREN"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjNGUO5CKI$Y#0o067S70Odm5p3YXcL0mW8gWePb51G54GSqH52QAYI9AW2EOiPWL5GKo" +
		"8WbdCpvpJCxzvVtMOrDDxkt3dKzpzl#hghVghggUdvtPcDXpGQb9mXm3tONxmRzo3CfIYhR" +
		"P5m0BAaJW0tN4iZaCVzCL0d8v3SHREHHV5ULUrPmP165FFsDvDPqlWTW4U2Zx0odW02x0YM" +
		"cjR1AnEyLK$Jt7UKRoriMuOixwscTQ71mNO49jWSxJ1LjWIEsXR193bhNw1uhojU2DnInXp" +
		"bxQPreS71BW3T#DUF8WPmLbuJDiYO2x5L$r2nNbFjRy4FuTHFndRU#bi2TolC2ZuJ$1Zy4D" +
		"mFlWmjX1YyLJVnx3Vrxmebhtt8uyNzmcGU6XR1B5ugf#ZsRQDOctVpPR0lO9KzNkJ44jczV" +
		"qisxPHRDBZnJs2LFLxaX1BPlKpBTksKMpIuyLqGQhwz2IKvG8SXYDm4lhXU9o0$XY04oEsR" +
		"QFOfCUBkmMfwdSd8HQtTd1UnBPj59lqU76N85NzhYJ4uipy$fpva6tRA3RfyU9EGQhwdKc8" +
		"nQb#K5ZTC7IMA2RkyU8sGQhwRKc8nQb#I5ZTC7IMA2RkyU9MGQhwhKc8nQb#U5ZTC7IMA2R" +
		"kyU8Y78MZKzKlIa8iJlKUONN3a3QAJNgehyGOZCDLc8Z9k0RNOXgknuru2e$Z2Sp679CrUi" +
		"pAECOsHYKQu54yYMNH41LeXCPeWgPO3itG75LeWPQCV3MMfRvgouF$PW6fXrYocPRDDZLYv" +
		"NbUUMR5Kcs7cvNERyJRClv9REFaVbBLV99wLdgiUUTU9lZUXRFbtujuCKSp4X5pj4Vfxrmu" +
		"5RuJyU9IpKX4NAezId$hmgdmhOWNipKZ4J5RUvJ#neLJuHiHBvxGZ4J44zgZzDSkd0fVYtZ" +
		"nk6Oa8XxN7gM$Sk5K#4h4YrcQaOYOfJrAV#d2gV2bY1UFQKOYuZ7jKVeB5qw5BqIyU5Gp4X" +
		"6FQe$IdxjmAdmkuiLCpKX4pDGUfJzpuLJuJCIB6PgHY9YXFKf$wiAfyAc85uzeHYBY4UrH#" +
		"XCNJeLFHBnuM3CI4GzhZz8Vkt0gV2pYnKEQaOXuI7kK$iY5K#4Z4I$cQaOYOgxEe$HhBfmA" +
		"huduO1df6Ei9NdVXi5yNyS4oqZ7M4xpXmc6$8UA3PQHZh2TuquN3VbF41yj8nrXFyA4BX$s" +
		"XY0#MaOwndk1f5mxxQH4VB2CTOpt1KouSzbCYFbX6EiPwWXTTEEmNHNomZ7ICzGGlk73OBu" +
		"ZuO1df6Ei95hXms0j4VB2CT8pr12#vSDWlYVXW6UaOwmaMkd3O2qLyi8nqZFK4hxXmsA#8#" +
		"60PwHZh2LvsuR1V5l71Cj8nrXEywi9XlohYWsMaOwmd#DM5m$vLn0VBICTOJp3VXSEUB#A3" +
		"PQHZh2VupON3$at41yD8Ntj4UNpN7ilNSEsHwzekE#CgjPvnrLhFk6QjPzoeXeoRgYlXQlT" +
		"kK#nHHbaDQ#5Mh83xCHsRuM4yZMVmB9x3FCNOsedXDMempqMQ9fOiNiJEYY6US#7mdXFnmJ" +
		"BICSIpBXpUio8#M4OwXdZ6XSDxHiG7mqWVKL4UtqguBVTA29vtuOnCxaLay29sLWnjjRBAW" +
		"dDhASyvmUykd77$BkA3OOpol4Dm4NR2C0p7nHY1It05TaOxx9ZNtR2PbFMS#s6zzFsmFE#6" +
		"5JGgHltX8ZKPCsbv98iNiTak#TufSEHvL5ofXef$nJ6lyHSRi#zzC5bvchq7jgZbd1sfjw#" +
		"3kRsiDcSckDwPTmJN9u4x3IlpjLinPgas7dipNZAsRZWPfohVpKc8HQMGS#PrOWDusR9j6u" +
		"kz9EunlakI44kEyGfZbkR5OaTml2Osz8r8GYmgXRx2so0suXSqsxQns8lZ7kExE0cnEAkfT" +
		"$Z#WM586uiT7lSOt$0anEBaFINCQnZIncA7nJt6Dom9iJXvJmlp6eQqiTYXSO$n3Kr2B3ds" +
		"cp1cQLuiTWWMsbY5AzWRai8LP86j0SDtZwts8SghsbZiXN4FCOgz2rCOfLYZB59vBrHUrSP" +
		"Y1ySzn4Zs1gSmKh56Qc3NrD4vM7bL6ukzAUuXBcVlfXGkLwpBDPoyDoclQcEnDyOzn6NitP" +
		"Z2POfr6NsNOXUa7iAmRIpsbhZ7#6v9GYpfRB6yXg4vOTHrSO$nNPU4M7BaDGpD2QDk26tHt" +
		"xCRaX1BZho6eJbHJ6ZJUGlvwpsw8FROWjZZ2s9FA8WzgI3srGMnfnJ4dbeG#xg2s3SKnBx9" +
		"VpuHJ4snvTYUYdrnHZ3LGYp1sPcVkpWG1uUCgS6rHYjBQ9DSrrhGUYrwuXZFEZOCOfhHoXB" +
		"Q9DSq2rgdvJWc34DpeXXZg$ciJMQaVOwPkoRaxHRMl4Qt5ghldpdXNArvKHHxLwChpgR7G5" +
		"dq8sFc56UovfbdEcQooZBPGbay8n4VCKdpp3CTCqbbcMIXB9wHY8#OeddccOwPeh9CiL0M$" +
		"rY4Cq7pp3CTCq5bcM2XBFwn2ESgpUDZRmp2#P3NiAk2YQera3vbeegPQ15Q34FQA8jbQ4ve" +
		"VSj#wYmsYhTq6opA#6JP8jFcNekT4Z7okP7CpwwXbV9dVh8iPuNE6NEN#NcLd5c6UlTdeNR" +
		"F$gp1NgnUh5wiNgnUhBvqL7Vk1TTGFNm4uzo4sXQCir0MoPRvoKZ56O#zC2IMOGnblEgD3p" +
		"56B6mDD8ljMCkZOfRWIh7HjoTRYok5nTP0#fJHfjfOx1bM5bk7OBH5nCfyT409Ib76zdXAE" +
		"PfpTWQ6xsbKcdSrcg2ArmaxyugwFQ$LTyFks8EH7Lcr4qUyEjPWx9fOIrsBhelri3usG6jc" +
		"sHYRC7OpR8ujq0PROYkqnTRO1jjYEsoF7R1ZMBs2A2UtdUebgxVBitexQbkzf83g5THIjpb" +
		"NHwLJlKMUrIi9MxsYWEeowWZfwkLvLfTzPwkN5xJjvGeb0H$fwhHugzCNLbUnfhhAacVr8F" +
		"4el3fRfphxhCwspgehzj9VNQ#FSjH3VIo31l9Ufs7$6TMTsgZu4wjdp7onUh7wObPFPOsDe" +
		"NF6Ek$EL#23U8OYtrWv38Vp$AK7hwJb$AOdUl4Sf3VwCFBOM9O1gZs9hxtUOpR6RawHpwfK" +
		"enMMnmfO4IjXPQo2Vs5LhAOOhPrvs10ReJKzcw9pB1EjIkSzOdMMaSwjZckr7pgdnvf$xYN" +
		"VSda5b6rChH7PSXdRfiKAnGh52iKA$wGArBLIGJ5QEp7szQDOeLYXMA5OeLYXMA5EAsHTrv" +
		"ZenRpso7LjLynOGCOwN4F5t7MNkmwEgB$3Ll$LylZV8UYClT45NR4FziL#w8RzSK0#TyFG5" +
		"rKupdS$BC#xOGMDAWXgdWsEgZb7LUUpMZSZprcnEEQQrwsNpHgMtRUsSwfv#FFdji0ZEZtl" +
		"sKUqicU#TgltyZgdZsXkH$Vu4PsLbnQTjn$bX5ZzasrUzo#5kkEGRzuw72$R$h4HdxAauot" +
		"q$OEbDU#IxZTL9xr#AoIlMwUGyVv$yoQEphzutY1OdBovraFsO#d8g$gBVUPJPFyZs2Lfjk" +
		"TlSkQvW#A5Qq#juzJQoyorDjQfQHtdcsjnZucypjfaHlAQkR1czAvndZENyvDApdPcpLmXM" +
		"NmZAIoBRoH$cx6KkA#iMNlElufyVyUphc1Dtbo#6jPY8aPcBVlp79NAdzTdFP8LCkPkCR9u" +
		"Ltc1Tj$#p6qlLYzMBrOlLYzMNpggkw#MkQl7M9btdLJhd8LwNkSIPmvHrdGMtpMw#THwybo" +
		"sGcMj8TQENST6O#Vp$CzwWTS6oJSkWk07ghM1HYTJDm3AFcH$F6K6qB0hK7uaPHHbDkL7eD" +
		"vQb0CeGoaFKZu3wgz8wKGvct8xvHsWQZZGk3UmJ5FcNGPeBh#7i3LjK$Xq9#h7gUKRBSlH9" +
		"xysl3rjlz4ctwTU4oYjKD#2GREvr7tvl0FrAK2JbSYHNpWyZyEjHzcI$LrOJtvjxtGASpOu" +
		"Xjln3L2nC$lZgFjJ9fFp0VsdiV#S6XBAsr0k09h#GX$7q9HZQz6IchLQS8vQiNwBZQXtf#v" +
		"6pTejUd2y0NK$wYxKLtACqwcluTZUexuLg6nCuRPMIln2wikfEIULdDFAJzd$d3LQ02sRKN" +
		"Ck6lsizWguhj1o5TgOk#LwrFAj6iuf7g5mRagseN0RInwW$CGvuRQNSh#LtaFvdjky6UEup" +
		"vhEeJwK#bjExyhizw7cDYr7RikH7E$h5DPhEP7RC93wHkenrFEfkK#RBsB$JSu9vw1gGsxt" +
		"ZXJcQtK6SqeE#JNSqK1r4yuVQpUTnze3#7m5FkVwgPOrmdcitekQSrTz83NdlPhpKO$he7e" +
		"4zHlKt3VrkP#hfr5lH$qiDRUzclkoFlTNDVTNVVa5GewjubVEhwmX#VyBNBgj6bBBzy0Vup" +
		"wMtpOjXVh5imRaBRi##vnNS8qjUmZb4cwJVCVg2VPdKdCjWtEqhAmxEHQuJy7zLyLnLidtj" +
		"EGNszvdVVarzdSfykkiyajVyljMj3LSbVjCVgD4Zfsst7RkLt3$bd3VbSWuohcMsvlZwuv1" +
		"wijAPVq7wO5B$oVRNnBXEDf4$SOTZEqmeuV4V5EDxSx8rkH#hHjDqRgoqd1UpwxL#0#jKMM" +
		"sY$kaxEaafydQ$h4s#rhhvcM6MsNq3bfNjJ6wbyc$qDIRhtN9NbgNTaZcBHrgzDp8LbRVw5" +
		"tTSJIQPxQtfs#ikKIEPQDdHBQI4R5#awYFPaPtDNfavAiQvg$HnF2RzKhQb#jZz22Znnfzk" +
		"z5pZ5vazFScJqEZLpEwhT5x9$DNl1qRmt3V#BB7tEYBGlY5vQxyFDkk7eDnAb#73#Gh$W3g" +
		"0Vmx89#exqDzCEKGzjDoq69A3vv9d4nz2gMVaZ9qL$V$at84ppmEvmlCOTI7ajERSeoIKlI" +
		"YxaNTa$wZwJ#Hpq$ayu6C6wXqAOwdxNZg8ob7qTwNSe2HplJbApkH7vVTFDAUTNQbxCx#7f" +
		"GzbPI5qedFEobTfkvexQLq6Q$cvUvMMKAwqDP5wJ9qPRyhzJxK#r3lIxqlzNxK#r5te#v6l" +
		"J$r$fmB#Jwdbb8Z9TYPUXTAH$OxAbsA4xZNJ#1plgfJIjItHqwYFexwEEhJ$WU1hI43");

	public PicoCParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // goal = block.block
			{
					final Symbol _symbol_block = _symbols[offset + 1];
					final Block block = (Block) _symbol_block.value;
					 return new Program(block);
			}
			case 1: // block = LBRACE.LBRACE block_statements_opt.l RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new Block(l);
			}
			case 2: // block_statements = block_statement.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Stmt b = (Stmt) _symbol_b.value;
					 return new List().add(b);
			}
			case 3: // block_statements = block_statements.l block_statement.b
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Stmt b = (Stmt) _symbol_b.value;
					 return l.add(b);
			}
			case 5: // local_variable_declaration_statement = local_variable_declaration.l SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final VarDeclStmt l = (VarDeclStmt) _symbol_l.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return l;
			}
			case 6: // local_variable_declaration = type.t IDENTIFIER.IDENTIFIER
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					 return new VarDeclStmt(t, IDENTIFIER);
			}
			case 7: // type = BYTE.BYTE
			{
					final Symbol BYTE = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("byte");
			}
			case 8: // type = SHORT.SHORT
			{
					final Symbol SHORT = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("short");
			}
			case 9: // type = INT.INT
			{
					final Symbol INT = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("int");
			}
			case 10: // type = LONG.LONG
			{
					final Symbol LONG = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("long");
			}
			case 11: // type = CHAR.CHAR
			{
					final Symbol CHAR = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("char");
			}
			case 26: // for_statement = FOR.FOR LPAREN.LPAREN for_init_opt.i SEMICOLON.SEMICOLON expression_opt.e SEMICOLON.SEMICOLON_ for_update_opt.u RPAREN.RPAREN statement.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol SEMICOLON = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Opt e = (Opt) _symbol_e.value;
					final Symbol SEMICOLON_ = _symbols[offset + 6];
					final Symbol _symbol_u = _symbols[offset + 7];
					final List u = (List) _symbol_u.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_s = _symbols[offset + 9];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(i, e, u, s);
			}
			case 29: // statement_expression_list = statement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final ExprStmt e = (ExprStmt) _symbol_e.value;
					 return new List().add(e);
			}
			case 30: // statement_expression_list = statement_expression_list.l COMMA.COMMA statement_expression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final ExprStmt e = (ExprStmt) _symbol_e.value;
					 return l.add(e);
			}
			case 31: // statement_expression = assignment.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new ExprStmt(a);
			}
			case 32: // statement_expression = preincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(e);
			}
			case 33: // statement_expression = predecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(e);
			}
			case 34: // statement_expression = postincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(e);
			}
			case 35: // statement_expression = postdecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(e);
			}
			case 36: // while_statement = WHILE.WHILE LPAREN.LPAREN expression.e RPAREN.RPAREN statement.s
			{
					final Symbol WHILE = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new WhileStmt(e, s);
			}
			case 37: // if_then_else_statement = IF.IF LPAREN.LPAREN expression.e RPAREN.RPAREN statement.t ELSE.ELSE statement.els
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_t = _symbols[offset + 5];
					final Stmt t = (Stmt) _symbol_t.value;
					final Symbol ELSE = _symbols[offset + 6];
					final Symbol _symbol_els = _symbols[offset + 7];
					final Stmt els = (Stmt) _symbol_els.value;
					 return new IfStmt(e, t, new Opt(els));
			}
			case 38: // if_then_statement = IF.IF LPAREN.LPAREN expression.e RPAREN.RPAREN statement.s
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new IfStmt(e, s, new Opt());
			}
			case 39: // labeled_statement = IDENTIFIER.id COLON.COLON statement.s
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol COLON = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new LabeledStmt(((String)id.value), s);
			}
			case 40: // return_statement = RETURN.RETURN expression_opt.expression SEMICOLON.SEMICOLON
			{
					final Symbol RETURN = _symbols[offset + 1];
					final Symbol _symbol_expression = _symbols[offset + 2];
					final Opt expression = (Opt) _symbol_expression.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new ReturnStmt(expression);
			}
			case 41: // continue_statement = CONTINUE.CONTINUE IDENTIFIER.id SEMICOLON.SEMICOLON
			{
					final Symbol CONTINUE = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new ContinueStmt(((String)id.value));
			}
			case 42: // continue_statement = CONTINUE.CONTINUE SEMICOLON.SEMICOLON
			{
					final Symbol CONTINUE = _symbols[offset + 1];
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new ContinueStmt("");
			}
			case 43: // break_statement = BREAK.BREAK IDENTIFIER.id SEMICOLON.SEMICOLON
			{
					final Symbol BREAK = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new BreakStmt(((String)id.value));
			}
			case 44: // break_statement = BREAK.BREAK SEMICOLON.SEMICOLON
			{
					final Symbol BREAK = _symbols[offset + 1];
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new BreakStmt("");
			}
			case 45: // do_statement = DO.DO statement.s WHILE.WHILE LPAREN.LPAREN expression.e RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol DO = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 2];
					final Stmt s = (Stmt) _symbol_s.value;
					final Symbol WHILE = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol SEMICOLON = _symbols[offset + 7];
					 return new DoStmt(s, e);
			}
			case 46: // switch_statement = SWITCH.SWITCH LPAREN.LPAREN expression.e RPAREN.RPAREN switch_block.l
			{
					final Symbol SWITCH = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final Block l = (Block) _symbol_l.value;
					 return new SwitchStmt(e, l);
			}
			case 47: // switch_block = LBRACE.LBRACE switch_statements.l RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new Block(l);
			}
			case 48: // switch_block = LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol RBRACE = _symbols[offset + 2];
					 return new Block(new List());
			}
			case 49: // switch_statements = switch_label.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Case s = (Case) _symbol_s.value;
					 return new List().add(s);
			}
			case 50: // switch_statements = switch_statements.l switch_label.s
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_s = _symbols[offset + 2];
					final Case s = (Case) _symbol_s.value;
					 return l.add(s);
			}
			case 51: // switch_statements = switch_statements.l block_statement.b
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Stmt b = (Stmt) _symbol_b.value;
					 return l.add(b);
			}
			case 52: // switch_label = CASE.CASE expression.e COLON.COLON
			{
					final Symbol CASE = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol COLON = _symbols[offset + 3];
					 return new ConstCase(e);
			}
			case 53: // switch_label = DEFAULT.DEFAULT COLON.COLON
			{
					final Symbol DEFAULT = _symbols[offset + 1];
					final Symbol COLON = _symbols[offset + 2];
					 return new DefaultCase();
			}
			case 54: // expression_statement = statement_expression.e SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final ExprStmt e = (ExprStmt) _symbol_e.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return e;
			}
			case 55: // empty_statement = SEMICOLON.SEMICOLON
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					 return new EmptyStmt();
			}
			case 59: // assignment = postfix_expression.dest EQ.EQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol EQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignSimpleExpr(dest, source);
			}
			case 60: // assignment = postfix_expression.dest MULTEQ.MULTEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol MULTEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignMulExpr(dest, source);
			}
			case 61: // assignment = postfix_expression.dest DIVEQ.DIVEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol DIVEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignDivExpr(dest, source);
			}
			case 62: // assignment = postfix_expression.dest MODEQ.MODEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol MODEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignModExpr(dest, source);
			}
			case 63: // assignment = postfix_expression.dest PLUSEQ.PLUSEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol PLUSEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignPlusExpr(dest, source);
			}
			case 64: // assignment = postfix_expression.dest MINUSEQ.MINUSEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol MINUSEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignMinusExpr(dest, source);
			}
			case 65: // assignment = postfix_expression.dest LSHIFTEQ.LSHIFTEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol LSHIFTEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignLShiftExpr(dest, source);
			}
			case 66: // assignment = postfix_expression.dest RSHIFTEQ.RSHIFTEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol RSHIFTEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignRShiftExpr(dest, source);
			}
			case 67: // assignment = postfix_expression.dest ANDEQ.ANDEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol ANDEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignAndExpr(dest, source);
			}
			case 68: // assignment = postfix_expression.dest XOREQ.XOREQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol XOREQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignXorExpr(dest, source);
			}
			case 69: // assignment = postfix_expression.dest OREQ.OREQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol OREQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignOrExpr(dest, source);
			}
			case 74: // literal = INTEGER_LITERAL.INTEGER_LITERAL
			{
					final Symbol INTEGER_LITERAL = _symbols[offset + 1];
					 return new IntegerLiteral(INTEGER_LITERAL);
			}
			case 75: // literal = LONG_LITERAL.LONG_LITERAL
			{
					final Symbol LONG_LITERAL = _symbols[offset + 1];
					 return new LongLiteral(LONG_LITERAL);
			}
			case 76: // literal = FLOATING_POINT_LITERAL.FLOATING_POINT_LITERAL
			{
					final Symbol FLOATING_POINT_LITERAL = _symbols[offset + 1];
					 return new FloatingPointLiteral(FLOATING_POINT_LITERAL);
			}
			case 77: // literal = DOUBLE_LITERAL.DOUBLE_LITERAL
			{
					final Symbol DOUBLE_LITERAL = _symbols[offset + 1];
					 return new DoubleLiteral(DOUBLE_LITERAL);
			}
			case 78: // literal = CHARACTER_LITERAL.CHARACTER_LITERAL
			{
					final Symbol CHARACTER_LITERAL = _symbols[offset + 1];
					 return new CharacterLiteral(CHARACTER_LITERAL);
			}
			case 79: // literal = STRING_LITERAL.STRING_LITERAL
			{
					final Symbol STRING_LITERAL = _symbols[offset + 1];
					 return new StringLiteral(STRING_LITERAL);
			}
			case 80: // postincrement_expression = postfix_expression.e PLUSPLUS.PLUSPLUS
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol PLUSPLUS = _symbols[offset + 2];
					 return new PostIncExpr(e);
			}
			case 81: // postdecrement_expression = postfix_expression.e MINUSMINUS.MINUSMINUS
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol MINUSMINUS = _symbols[offset + 2];
					 return new PostDecExpr(e);
			}
			case 83: // simple_name = IDENTIFIER.IDENTIFIER
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					 return new ParseName(IDENTIFIER);
			}
			case 85: // multiplicative_expression = multiplicative_expression.e1 MULT.MULT unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MULT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new MulExpr(e1, e2);
			}
			case 86: // multiplicative_expression = multiplicative_expression.e1 DIV.DIV unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol DIV = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new DivExpr(e1, e2);
			}
			case 87: // multiplicative_expression = multiplicative_expression.e1 MOD.MOD unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MOD = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ModExpr(e1, e2);
			}
			case 89: // additive_expression = additive_expression.e1 PLUS.PLUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol PLUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AddExpr(e1, e2);
			}
			case 90: // additive_expression = additive_expression.e1 MINUS.MINUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MINUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new SubExpr(e1, e2);
			}
			case 92: // shift_expression = shift_expression.e1 LSHIFT.LSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LShiftExpr(e1, e2);
			}
			case 93: // shift_expression = shift_expression.e1 RSHIFT.RSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol RSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new RShiftExpr(e1, e2);
			}
			case 95: // relational_expression = relational_expression.e1 LT.LT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LTExpr(e1, e2);
			}
			case 96: // relational_expression = relational_expression.e1 GT.GT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol GT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GTExpr(e1, e2);
			}
			case 97: // relational_expression = relational_expression.e1 LTEQ.LTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LEExpr(e1, e2);
			}
			case 98: // relational_expression = relational_expression.e1 GTEQ.GTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol GTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GEExpr(e1, e2);
			}
			case 100: // equality_expression = equality_expression.e1 EQEQ.EQEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol EQEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new EQExpr(e1, e2);
			}
			case 101: // equality_expression = equality_expression.e1 NOTEQ.NOTEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol NOTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new NEExpr(e1, e2);
			}
			case 103: // and_expression = and_expression.e1 AND.AND equality_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol AND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndBitwiseExpr(e1, e2);
			}
			case 105: // exclusive_or_expression = exclusive_or_expression.e1 XOR.XOR and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol XOR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new XorBitwiseExpr(e1, e2);
			}
			case 107: // inclusive_or_expression = inclusive_or_expression.e1 OR.OR exclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol OR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrBitwiseExpr(e1, e2);
			}
			case 109: // conditional_and_expression = conditional_and_expression.e1 ANDAND.ANDAND inclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol ANDAND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndLogicalExpr(e1, e2);
			}
			case 111: // conditional_or_expression = conditional_or_expression.e1 OROR.OROR conditional_and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol OROR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrLogicalExpr(e1, e2);
			}
			case 113: // conditional_expression = conditional_or_expression.c QUESTION.QUESTION expression.e1 COLON.COLON conditional_expression.e2
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					final Symbol QUESTION = _symbols[offset + 2];
					final Symbol _symbol_e1 = _symbols[offset + 3];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol COLON = _symbols[offset + 4];
					final Symbol _symbol_e2 = _symbols[offset + 5];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ConditionalExpr(c, e1, e2);
			}
			case 116: // unary_expression = PLUS.PLUS unary_expression.e
			{
					final Symbol PLUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new PlusExpr(e);
			}
			case 117: // unary_expression = MINUS.MINUS unary_expression.e
			{
					final Symbol MINUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new MinusExpr(e);
			}
			case 119: // preincrement_expression = PLUSPLUS.PLUSPLUS unary_expression.e
			{
					final Symbol PLUSPLUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new PreIncExpr(e);
			}
			case 120: // predecrement_expression = MINUSMINUS.MINUSMINUS unary_expression.e
			{
					final Symbol MINUSMINUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new PreDecExpr(e);
			}
			case 122: // unary_expression_not_plus_minus = COMP.COMP unary_expression.e
			{
					final Symbol COMP = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new BitNotExpr(e);
			}
			case 123: // unary_expression_not_plus_minus = NOT.NOT unary_expression.e
			{
					final Symbol NOT = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new LogNotExpr(e);
			}
			case 124: // for_init_opt = 
			{
					 return new List();
			}
			case 125: // for_init_opt = for_init.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 126: // for_update_opt = 
			{
					 return new List();
			}
			case 127: // for_update_opt = for_update.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 128: // block_statements_opt = 
			{
					 return new List();
			}
			case 129: // block_statements_opt = block_statements.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 130: // expression_opt = 
			{
					 return new Opt();
			}
			case 131: // expression_opt = expression.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Expr n = (Expr) _symbol_n.value;
					 return new Opt(n);
			}
			case 4: // block_statement = statement.statement
			case 12: // statement = labeled_statement.labeled_statement
			case 13: // statement = if_then_statement.if_then_statement
			case 14: // statement = if_then_else_statement.if_then_else_statement
			case 15: // statement = while_statement.while_statement
			case 16: // statement = for_statement.for_statement
			case 17: // statement = expression_statement.expression_statement
			case 18: // statement = block.block
			case 19: // statement = empty_statement.empty_statement
			case 20: // statement = switch_statement.switch_statement
			case 21: // statement = do_statement.do_statement
			case 22: // statement = break_statement.break_statement
			case 23: // statement = continue_statement.continue_statement
			case 24: // statement = return_statement.return_statement
			case 25: // statement = local_variable_declaration_statement.local_variable_declaration_statement
			case 27: // for_init = statement_expression_list.statement_expression_list
			case 28: // for_update = statement_expression_list.statement_expression_list
			case 56: // expression = assignment_expression.assignment_expression
			case 57: // assignment_expression = conditional_expression.conditional_expression
			case 58: // assignment_expression = assignment.assignment
			case 70: // postfix_expression = literal.literal
			case 71: // postfix_expression = name.name
			case 72: // postfix_expression = postincrement_expression.postincrement_expression
			case 73: // postfix_expression = postdecrement_expression.postdecrement_expression
			case 82: // name = simple_name.simple_name
			case 84: // multiplicative_expression = unary_expression.unary_expression
			case 88: // additive_expression = multiplicative_expression.multiplicative_expression
			case 91: // shift_expression = additive_expression.additive_expression
			case 94: // relational_expression = shift_expression.shift_expression
			case 99: // equality_expression = relational_expression.relational_expression
			case 102: // and_expression = equality_expression.equality_expression
			case 104: // exclusive_or_expression = and_expression.and_expression
			case 106: // inclusive_or_expression = exclusive_or_expression.exclusive_or_expression
			case 108: // conditional_and_expression = inclusive_or_expression.inclusive_or_expression
			case 110: // conditional_or_expression = conditional_and_expression.conditional_and_expression
			case 112: // conditional_expression = conditional_or_expression.conditional_or_expression
			case 114: // unary_expression = preincrement_expression.preincrement_expression
			case 115: // unary_expression = predecrement_expression.predecrement_expression
			case 118: // unary_expression = unary_expression_not_plus_minus.unary_expression_not_plus_minus
			case 121: // unary_expression_not_plus_minus = postfix_expression.postfix_expression
			{
				return _symbols[offset + 1];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
