%header {:
package AST;
import AST.*;
import utility.LabelUtility;
:};


%left LPAREN, RPAREN;
//%right PLUSPLUS, MINUSMINUS;
%left MULT, DIV, MOD;
%left PLUS, MINUS;
%left LT, GT, LTEQ, GTEQ;
%left EQEQ, NOTEQ;
%left AND;
%left XOR;
%left OR;
//%right EQ, PLUSEQ, MINUSEQ, MULTEQ, DIVEQ, MODEQ;


Program goal =
  block				{: return new Program(block); :}
  ;

Stmt block =
    LBRACE block_statements.l RBRACE {: return new CompoundStmt(l); :}
  ;

List block_statements =
    statement.s                     {: return new List().add(s); :}
  | block_statements.l statement.s  {: return l.add(s); :}
  ;

Stmt statement =
    IDENTIFIER ASSIGN expression.e   {: return new AssignStmt(new NumLabel(LabelUtility.nextLabel()), IDENTIFIER, e); :}
  | SKIP                            {: return new SkipStmt(new NumLabel(LabelUtility.nextLabel()), SKIP); :}
  | block                            {: return block; :}
  | if_then_else_statement
  | if_then_statement
  | WHILE expression.be DO block     {: return new WhileStmt(new LabeledExpr(new NumLabel(LabelUtility.nextLabel()), be), block); :}
  | for_stmt
  | SEMICOLON						 {: return new EmptyStmt(); :} 
 // | return_stmt
 // | break_stmt
  ;

ForStmt for_stmt =
    FOR LPAREN expression.i SEMICOLON expression.e SEMICOLON expression.u RPAREN block.s 
												{: return new ForStmt(i, new LabeledExpr(new NumLabel(LabelUtility.nextLabel()), e), u, s); :}
  ;

IfStmt if_then_else_statement =
    IF LPAREN expression.e RPAREN statement.t SEMICOLON ELSE statement.els	
												{: return new IfStmt(new LabeledExpr(new NumLabel(LabelUtility.nextLabel()), e), t, new Opt(els)); :}
  ;
IfStmt if_then_statement =
    IF LPAREN expression.e RPAREN statement.s						
												{: return new IfStmt(new LabeledExpr(new NumLabel(LabelUtility.nextLabel()), e), s, new Opt()); :}
  ;

//ReturnStmt return_stmt =
//    RETURN expression.e SEMICOLON				{: return new ReturnStmt(new LabeledExpr(new NumLabel(LabelUtility.nextLabel(), e))); :}
 // ;

//BreakStmt break_stmt =
  //  BREAK IDENTIFIER.id SEMICOLON				{: return new BreakStmt(new NumLabel(LabelUtility.nextLabel()), id); :}
 // | BREAK               SEMICOLON				{: return new BreakStmt(new NumLabel(LabelUtility.nextLabel())); :}
 // ;

 Expr primary =
    IDENTIFIER               {: return new VarRefExpr(IDENTIFIER); :}
  | NUMBER                   {: return new NumLitExpr(NUMBER); :}
  | TRUE                     {: return new BoolLitExpr(TRUE); :}
  | FALSE                    {: return new BoolLitExpr(FALSE); :}
  | NOT primary.e            {: return new NotExpr(e); :}
  | LPAREN expression.e RPAREN {: return e; :}
     ;

Expr simplefact_exp =
	  primary.p											{: return p; :}			
	| simplefact_exp.s EQ primary.p						{: return new ABinaryExpr(s, new Op_arth(EQ), p); :}							
	| simplefact_exp.s MULT primary.p					{: return new ABinaryExpr(s, new Op_arth(MULT), p); :}
	| simplefact_exp.s DIV primary.p					{: return new ABinaryExpr(s, new Op_arth(DIV), p); :}
	| simplefact_exp.s MOD primary.p					{: return new ABinaryExpr(s, new Op_arth(MOD), p); :}
	;

Expr simpleae =
	   simplefact_exp.se								{: return se; :}							
	 | simpleae.a PLUS simplefact_exp.s					{: return new ABinaryExpr(a, new Op_arth(PLUS), s); :} 
	 | simpleae.a MINUS simplefact_exp.s				{: return new ABinaryExpr(a, new Op_arth(MINUS), s); :}
	 ;

Expr relexp =
       simpleae.s										{: return s; :}								
     | simpleae.a EQEQ simpleae.b						{: return new RelExpr(a, new Op_rel(EQEQ), b); :}
	 | simpleae.a NOTEQ simpleae.b						{: return new RelExpr(a, new Op_rel(NOTEQ), b); :}
	 | simpleae.a LT simpleae.b							{: return new RelExpr(a, new Op_rel(LT), b); :}
	 | simpleae.a GT simpleae.b							{: return new RelExpr(a, new Op_rel(GT), b); :}
	 | simpleae.a LTEQ simpleae.b						{: return new RelExpr(a, new Op_rel(LTEQ), b); :}
	 | simpleae.a GTEQ simpleae.b						{: return new RelExpr(a, new Op_rel(GTEQ), b); :}
     ;

Expr and_expression =
    relexp.re											{: return re; :}						
  | and_expression.e AND relexp.r						{: return new LogicExpr(e, new Op_bool(AND), r); :}
  ;
Expr exclusive_or_expression =
    and_expression.ae									{: return ae; :}							
  | exclusive_or_expression.e XOR and_expression.a		{: return new LogicExpr(e, new Op_bool(XOR), a); :}
  ;
Expr expression =
    exclusive_or_expression.ee							{: return ee; :}				
  | expression.ie OR exclusive_or_expression.ee	
														{: return new LogicExpr(ie, new Op_bool(OR), ee); :}
  ;
  
  
  
  //comment all -  will add it later
 /*Expr assignment_expression =
	assignment;
Expr assignment =             		  
    postfix_expression.a EQ assignment_expression.p		{: return new ABinaryExpr(a, new Op_arth(EQ), p); :}
  | postfix_expression.a MULTEQ assignment_expression.p	{: return new ABinaryExpr(a, new Op_arth(MULTEQ), p); :}
  | postfix_expression.a DIVEQ assignment_expression.p	{: return new ABinaryExpr(a, new Op_arth(DIVEQ), p); :}
  | postfix_expression.a MODEQ assignment_expression.p	{: return new ABinaryExpr(a, new Op_arth(MODEQ), p); :}
  | postfix_expression.a PLUSEQ assignment_expression.p	{: return new ABinaryExpr(a, new Op_arth(PLUSEQ), p); :}
  | postfix_expression.a MINUSEQ assignment_expression.p	{: return new ABinaryExpr(a, new Op_arth(MINUSEQ), p); :}
  ;
Expr postfix_expression =
    assignment							
  | postincrement_expression
  | postdecrement_expression
  ;

Expr postincrement_expression =
    postfix_expression.e PLUSPLUS						{: return new ABinaryExpr(e, new Op_arth(PLUSPLUS)); :}
  ;
Expr postdecrement_expression =
    postfix_expression.e MINUSMINUS						{: return new ABinaryExpr(e, new Op_arth(MINUSMINUS)); :}
  ;
 */

//Access type =
//    BYTE		{: return new PrimitiveTypeAccess("byte"); :}
//  | SHORT		{: return new PrimitiveTypeAccess("short"); :}
//  | INT 		{: return new PrimitiveTypeAccess("int"); :}
//  | LONG		{: return new PrimitiveTypeAccess("long"); :}
//  | CHAR		{: return new PrimitiveTypeAccess("char"); :}
//  ;
