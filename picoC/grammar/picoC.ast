Program ::= Stmt;

abstract Label;
NumLabel:Label ::= <Num>;

abstract Stmt;
AssignStmt : Stmt ::= LabelAST:Label <Var> Expr;
IfStmt : Stmt ::= LabeledExpr Then:Stmt [Else:Stmt];
SkipStmt : Stmt ::= LabelAST:Label <String>;
EmptyStmt : Stmt ::= LabelAST:Label;
CompoundStmt : Stmt ::= SList:Stmt*;
ForStmt : Stmt ::= InitStmt:Expr LabeledExpr UpdateStmt:Expr LastStmt:Stmt;
WhileStmt : Stmt ::= LabeledExpr Stmt;
//ReturnStmt : Stmt ::= LabelAST:Label [Result:Expr];

abstract Op ::= <Contents>;
Op_bool : Op;
Op_rel : Op;
Op_arth : Op;


abstract Expr;

VarRefExpr: Expr ::= <Contents>;
NumLitExpr: Expr ::= <Contents>;
ABinaryExpr: Expr ::= Left:Expr Op:Op_arth Right:Expr;

BoolLitExpr:Expr ::= <Contents>;
NotExpr: Expr ::= Expr;
LogicExpr: Expr ::= Left:Expr Op:Op_bool Right:Expr;
RelExpr: Expr ::= Left:Expr Op:Op_rel Right:Expr;
LabeledExpr: Expr ::= LabelAST:Label Expr; 

//abstract PrimaryExpr : Expr;
//abstract Literal : PrimaryExpr ::= <LITERAL:String>;
//CharacterLiteral : Literal ;
//StringLiteral : Literal ;
//IntegerLiteral : Literal ;
//LongLiteral : Literal ;
//FloatingPointLiteral : Literal ;
//DoubleLiteral : Literal ;

// Access expressions (whatever that means)
//abstract Access : Expr ::= <ID:String>;
//TypeAccess : Access;
//PrimitiveTypeAccess : TypeAccess;
//ParseName : Access;

