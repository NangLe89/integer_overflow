import java.util.Set;
import utility.Pair;
import utility.SetRepUtility;
import AST.*;

/** The Integer Overflow Analysis.
 *  Based on initial work by Mario Lopez.
    See IOver.jrag for some helping attributes. */
aspect IO {
	/** The kill function for integer overflow. */
	syn Set<Map.Entry> Block.killIO();
	eq AssignStmt.killAE() {
		Set<Map.Entry> ret = SetRepUtility.crossWith(Integer,SetRepUtility.crossWith(getVar(), Integer));
		ret.addAll(SetRepUtility.crossWith(Integer,SetRepUtility.crossWith(getVar(), Integer)));
		return ret;
	}
	eq SkipStmt.killIO() = SetRepUtility.emptySet();
	eq LabeledExpr.killIO() = SetRepUtility.emptySet();
	
	/** The gen function for available expressions. */
	syn Set<Map.Entry> Block.genIO();
	eq AssignStmt.genIO() 
	 = SetRepUtility.singleton(
	         new Pair<String,Integer>(getVar(), new Pair<Integer, Integer>(getInt(), getInt())));
	eq SkipStmt.genIO() = SetRepUtility.emptySet();
	eq LabeledExpr.genIO() = SetRepUtility.emptySet();


	/** Compute the entry information for the AE analysis. */
	syn Set<Map.Entry> Block.IOentry() circular [SetRepUtility.emptySet()];
        eq Block.IOentry() {
		Set<Map.Entry> ret = SetRepUtility.emptySet() ;
		if (getLabelAST().equals(progInitLabel())) {
			ret.addAll(SetRepUtility.crossWith(Integer,SetRepUtility.crossWith(Integer(progFV(), Integer)));
		} else {
			for (Label l : inFlows()) {
				Block b = l.itsBlock();
				ret.addAll(b.IOexit());
				}
		}
		return ret;
	}

	/** Compute the exit information for the IO analysis. */
	syn Set<Map.Entry> Block.IOexit() circular [SetRepUtility.emptySet()];
	eq Block.IOexit() {
		Set<Expr> ret = SetRepUtility.emptySet(); 
		ret.addAll(this.IOentry());
		ret.removeAll(this.killIO(ret));
		ret.addAll(this.genIO());		
		return ret;
	}
}
