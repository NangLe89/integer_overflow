// Generated from parser/picoC.parser
package AST;
import AST.*; 
import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "PicoCParser.beaver".
 */
public class PicoCParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short SEMICOLON = 1;
		static public final short PLUSPLUS = 2;
		static public final short MINUSMINUS = 3;
		static public final short IDENTIFIER = 4;
		static public final short RPAREN = 5;
		static public final short INTEGER_LITERAL = 6;
		static public final short LONG_LITERAL = 7;
		static public final short FLOATING_POINT_LITERAL = 8;
		static public final short DOUBLE_LITERAL = 9;
		static public final short CHARACTER_LITERAL = 10;
		static public final short STRING_LITERAL = 11;
		static public final short COMMA = 12;
		static public final short PLUS = 13;
		static public final short MINUS = 14;
		static public final short COLON = 15;
		static public final short QUESTION = 16;
		static public final short OROR = 17;
		static public final short ANDAND = 18;
		static public final short OR = 19;
		static public final short XOR = 20;
		static public final short AND = 21;
		static public final short EQEQ = 22;
		static public final short NOTEQ = 23;
		static public final short LT = 24;
		static public final short GT = 25;
		static public final short LTEQ = 26;
		static public final short GTEQ = 27;
		static public final short COMP = 28;
		static public final short NOT = 29;
		static public final short LSHIFT = 30;
		static public final short RSHIFT = 31;
		static public final short WHILE = 32;
		static public final short FOR = 33;
		static public final short DO = 34;
		static public final short IF = 35;
		static public final short GOTO = 36;
		static public final short CONTINUE = 37;
		static public final short BREAK = 38;
		static public final short LBRACE = 39;
		static public final short BYTE = 40;
		static public final short SHORT = 41;
		static public final short INT = 42;
		static public final short LONG = 43;
		static public final short CHAR = 44;
		static public final short RBRACE = 45;
		static public final short MULT = 46;
		static public final short DIV = 47;
		static public final short MOD = 48;
		static public final short ELSE = 49;
		static public final short EQ = 50;
		static public final short MULTEQ = 51;
		static public final short DIVEQ = 52;
		static public final short MODEQ = 53;
		static public final short PLUSEQ = 54;
		static public final short MINUSEQ = 55;
		static public final short LSHIFTEQ = 56;
		static public final short RSHIFTEQ = 57;
		static public final short ANDEQ = 58;
		static public final short XOREQ = 59;
		static public final short OREQ = 60;
		static public final short LPAREN = 61;

		static public final String[] NAMES = {
			"EOF",
			"SEMICOLON",
			"PLUSPLUS",
			"MINUSMINUS",
			"IDENTIFIER",
			"RPAREN",
			"INTEGER_LITERAL",
			"LONG_LITERAL",
			"FLOATING_POINT_LITERAL",
			"DOUBLE_LITERAL",
			"CHARACTER_LITERAL",
			"STRING_LITERAL",
			"COMMA",
			"PLUS",
			"MINUS",
			"COLON",
			"QUESTION",
			"OROR",
			"ANDAND",
			"OR",
			"XOR",
			"AND",
			"EQEQ",
			"NOTEQ",
			"LT",
			"GT",
			"LTEQ",
			"GTEQ",
			"COMP",
			"NOT",
			"LSHIFT",
			"RSHIFT",
			"WHILE",
			"FOR",
			"DO",
			"IF",
			"GOTO",
			"CONTINUE",
			"BREAK",
			"LBRACE",
			"BYTE",
			"SHORT",
			"INT",
			"LONG",
			"CHAR",
			"RBRACE",
			"MULT",
			"DIV",
			"MOD",
			"ELSE",
			"EQ",
			"MULTEQ",
			"DIVEQ",
			"MODEQ",
			"PLUSEQ",
			"MINUSEQ",
			"LSHIFTEQ",
			"RSHIFTEQ",
			"ANDEQ",
			"XOREQ",
			"OREQ",
			"LPAREN"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjN0USLCKT$gvHl9FZ3Wls5ZnHmOBTY2A80W828gA2e28e0aPZB36Ms1MbDqNfI2yYpGC" +
		"fbiHOa5Ymn8AQn0O8QgA8UNupyv#tyzxkUtihvu5Xz$lzvvl$pB$CpCw#Sc$tW3gBlQSKC8" +
		"ao5HCy3u#Z3dOrhT70xjXJymLeYtDmAIv3Tro2tlWTEkBtk1vdOM#nt2yYncADVtgBSG0EG" +
		"ZqSWiEmJ5eZWQFHI7DKtXjnh5WU5n7ZMGNSIvc8APYEMTxttZscDHgOYVcQe$B#qVjERFyR" +
		"4UCPZGSe$$6#zRxn7WHVqXe9QnEPzqysHcIibGhiNGddPLgZOMqYyhR4XRWe4JabLYYmTqK" +
		"WxufuM1lqnqCOYC4OYk4OYOSn6ezXh1iZCjPo1VOk3#HT7Wzh4p7VFoHYHCPQfi3UPO6yo#" +
		"9XRLBcFTkD4HdhQGNsFXt8#tGyh4tAlDUwCI9ZBLLWxz90tgNny6qUmdau7rTHxO7BqHEzS" +
		"0MkT6D4nbgYmDubWRnBuc5jJ5QlVt9M6oCoLha2Uyi3USlZOMsIrhaDrpaG8pBM8WNsBWha" +
		"NHGFQvEKjxsJru#S4WiLsBima7TXFAnDKjvpdRn#v9GOf8ujx1qKo3ie7jOcAMyd9w#rJ7r" +
		"iMO0vc8idC4yyrSliqTafTaiP6c8QdaGUyb60QgYE6gY9dL288koCMhH8xC$3SMWukhVQ#v" +
		"Vt4SUq6hCLomXNympu4SiovAQ9RZs#zd6tK$$QMolzP6#JZxLEVLF8Fmb#XatH49jDtaOBQ" +
		"XiTV2WMPEyh7nywzQzq$yPeI8IDhayOOlELjy62sWO77ui5sLllusEdlbxtRuY6HDZW#eGX" +
		"DkkzTHRKrZduH2p8tfS#Fd7gN#h#TT6G2EjSdp34vall2mjgNxYQiuS#jt3hIWlwX27UNxW" +
		"#OVWPFhEWzfchEUFurCAjAote4uPuV#RwXE5dUDU2shkkvepZ7nPkNMb1dp34#rtN9mm$mt" +
		"iMrDvpDMSS$xPmwqeB#eGXtk#vFc7u6LwteFQwgpdZ#9#5MrTQq2SCyNxTzGd3PaWwFhugF" +
		"Q$ow9iOoQjIfZ$wDl1Uiw37Qwxcn7l3mgqhBUWJXdY$vlg4uMTOOq5jZQivutZJmgqhBUWJ" +
		"XdYlSNt2y3EyRK7jRLTpnl6MXLjNMj0d3F5#s$K9my#msOBQPbTpnl6EXLjNMj0d3F7UxFg" +
		"4OJCaxRXHqZCgiED6ILc6ajWT5uwsIlnN1QAjah8CksKKxHNnVoKGxHKfor0tesWlY$$BWM" +
		"WlIrc6VMAZFH1n9teBJiJj#3Fkm9su2$VZ99o0uvDoloJPNfBSAqKxK9TbE3YZcRmeqLuCp" +
		"EH5ASjmL5oqIhxIx9nqfPdPIaNTuT$2WBUZ6NR9CDuH#kgr62dkiFHhhrYBFR0lZaGfPc0o" +
		"ngC#5c8H5kCfb7ltfxMupzjYm9NOae2ipGy6YPhHd7TWImn#Y4ObhdTpoZ6PnVD#DE3uVqp" +
		"0cTOzSUlj#eIHRhrZugRR0$5nT#YCtbnvP#O6zkRSUD3YOSk#ptoZUVDPtesJqHfzq8zQB6" +
		"Z$Dyj#f956yqQQDh4T6G$QlM3PZpJ2QDu8qoQs8#91kxzQzYCDDvettBI9xV1uqEulblr8m" +
		"upc3JDjOZii7hHxth8VQQZHlA6cJMo7neDsprds8mqncZV4j8dja7ZGxk#M$KY3BPisiHqS" +
		"3$4O7DY30qDiR0V6mtXO7$4S469ZEo0UniFwYEUJ8JQsJyR3U5WVyPmNOcCxBnx6m$g8vu8" +
		"G6zi5yJ0UraSyvuJOsCw9X$6mFkBvH93bMF14F8m7ENpEwfguvZ2HCZfdFPYHzO2Ch3Ex#X" +
		"cIaVMmZAn7P6GzAYFhHpAoVZGZwp4PMOzBS$teMj$dpP9TE2kmDsUX5QxnPaLYfh8nx7ZDr" +
		"5up8p5RsHXsl6PhhzbHC3RaYitgjnMoQ#nDb#pJ0sEPRif8J6Dt2rodEU4rpPIHc2fUKmDU" +
		"KqqPYIdYDINWDSMKaPWXNZC2NZDC6GLjHAyAhDrfqJRUP6rpEjdDFTcKOU1Ct82RSBCtIUm" +
		"c1RmccJ8Ct#jnxmFzR97iU6cDPGY#r$lwkU0ZtllQ#X7nSZJs4JX5Ftz8$JoqjdTln1EhTk" +
		"WG$ImJNN2nCzBKpqpYrl#swAmnFIfhgkSPPZopK$IjY7ZMeQBP9xZFOdz$Ai#4PcUUFlv6e" +
		"YpDUBJXDUYcpsogv#VEFnonRwL7l7gh8wP#PIDc8sOZPYDMHSJmcI0HCTMPOBatmRXPzZNw" +
		"UHDSu0pSwasK$ea1wuccTA6jnqd$k83rE5CcWARUUEaR7x0SRye4Q3b6#iRuLcEDvetrnbY" +
		"WYMhLRGAsF2hsbXypccAM6ZXLMXype3vQh4S7HZRQb0eu1Jd8HHxB0ae#E$BPLY1$uIv6RP" +
		"IW57Mm2tR5RjWTTR47ziHUE8fM#s8$DCQfl1vhWjFH5CsuRirvdNCMh#DQCaP3784ZQNSq6" +
		"k4O78lZS3pl3KxaDV$9l4OsUGjqNfEz0REcoxj$XVFcnEOjbhmMwVBc4$5vyoLlVjhvvcla" +
		"U7obowjjOlEoN#Sbn#HbRu7dlBOwhvhBBvatPKo9iGtckstoRglvLa5Uysd8f#Oy2Qk2lBd" +
		"9pz$y65MypjcysrNUaAVsCBkbLOezsf7N9PruPTAPzs7gkMqNTEMrIZTztS9xCbfSxkVjpU" +
		"kNyBZqMKVDaj4Bd5ag5AUFxdl0VfBGB$1CEKVw2m8sHU6Py7nw00x4GRnNheU3KOP3K1#7u" +
		"Z0SZWOIuQWAsI3r9pexZkrp787FLenDTXpPSLJ9E9AEZ$PpWbREI8fqMO7Z8#yLjvUPPSUn" +
		"VOwZKdVS3XmjSGVS2cUZDThelqktGtjqmBdfSgE7oOqhji5CVk4hpQrSAVSENrdto31Ucay" +
		"PuyNTWwN$1CLOn4PE$#cFYnpNLudhhTVdrxBUqSVAj6iT6tS7psYFBPaT7JWU7XrSFtsVLw" +
		"IFKiRF71ssCf9pdCb6#fL4ClifiqZcR1FOWw6TcOsqeqIgkckEhFN$ZxLSFxhMF#lSfe#5Q" +
		"XTMWLVSZayvguhPHSnRbndFuDVkbT4QH#$57B79UCG$vvr8F4KDxAMYD5xoXDlDABc26PLT" +
		"wgS3nL7NcNeVHpwjnDxOnnbfXPuyXDO$Ecjq3xEcUfvXniEZHr8VxvLJFklGqJgARq$qycV" +
		"I9pWxzDJbbHAbxzQErfpPT4ybpNzxZEYbV6KZPYDc8sOZLaN4f6EQ7p7rcI3oob7v9P#1Cp" +
		"lBLznwAooJ$XfZB9DzmtTgzljQ1G6xi5z5HWOyTvl#9bvDzLkpwa3U1vIDGFv1b6CfFIatK" +
		"gPJbb8s00Kvb4QKCu3YE#dx8UlNC#nBrDLlxmlOjexwvy1EUr2zZtN6BLR$2QICRGUphPnj" +
		"NmEv9x7jDFOD8JUXVXsvCMtQqqRzyhufsGDggF#gKXUeLiBw5iQlJpcU#bMqLT$PP9tNLwY" +
		"TIxwKqfjzjm25qpYVfrXlIRl7sL#FkQub7mtKUO3SXjoNV26v6VbwycvapgjuF$9Oe1R7L7" +
		"iciFFtv1SOH$czIPv3UOEocVecvbBs76iXunHU0PHmF8KFaGyXp#EuRzPh3rvfeKJPl4LkH" +
		"rQ$P6PUg5$fSNrp3gDmtNCcKBXkkOoJsud2DSfTnVaKqgyFK7GW#IRocHIkGybmyY3A0jRf" +
		"MsiNoX6iBoCF9FFzgSNtiUHJylEKjQn$otdoFIZko7ate7Icg3LWhbAkjVgUREc#t1fti6q" +
		"oSpDNAUshSrrBMQ##ciprhluT#MhEyJXoVt8NyYYk3NEMpYTpJvMkv5ovjgNlaxa6fNnF2x" +
		"inBlTTuLtCfTwxc$bUSLshhTJV$uJwFtxLlc7yQgpp$Qn#0bdzml9MrlcUvYsXS9$bD#GSp" +
		"gDm352$vUIspk7Uq$yRJtslbcE0#ktYGkuRzHrTzTj1pYEFOys$XgBwRgUKiwtSV2RohhlD" +
		"1CfOEBR6YNgDVjBMGxY$qpT2skObsefdITixeYyHVMCmHrxpHBrQGR2lHjr4lMPP$5XhbGZ" +
		"N4tv6#0s9TRV4qNFY5bvhTAmsd7ENuTp0Ub6VAxpE6NDzYTarUHn58mtNBWZtLKJerr2uKw" +
		"8jPuLJRv6eOn$XpiB34dt5TqJdgDdMyCwJGsEVAhnSU8tmUh4l4DvRk95mI#7kmZS83wZel" +
		"2jR#BbSaRfTlsv4Fzv$TkLvkJUvDp#pbvCl9NUYdCzwMCxBK2xYURuFkI#bfvOyTRPFaWjv" +
		"dhc0vwpExB#CSecMN7GdToTtOryNyiMqLK#ypXLfnVwAIcFQkz8qGfemp#cKPgohRzITfIN" +
		"FbnRKMsZEqt#dQAavZ$VKwcyMUG5fpRRMclFGXlKsvBRajkHpoEUGsv7RaTkJsvCxa3jmFP" +
		"gJZUIAvF2gAfTds5pUoUTGShNquZlPYxhw$SALPFLhYAl8F6jHSd3rJngM4Om=");
 // Generated from parser/picoC.parser
int l = 1; // l means label

	public PicoCParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // goal = statement.statement
			{
					final Symbol _symbol_statement = _symbols[offset + 1];
					final Stmt statement = (Stmt) _symbol_statement.value;
					 return new Program(statement);
			}
			case 1: // block = LBRACE.LBRACE block_statements_opt.list RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_list = _symbols[offset + 2];
					final List list = (List) _symbol_list.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new Block(l++, list);
			}
			case 2: // block_statements = block_statement.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Stmt b = (Stmt) _symbol_b.value;
					 return new List().add(b);
			}
			case 3: // block_statements = block_statements.l block_statement.b
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Stmt b = (Stmt) _symbol_b.value;
					 return l.add(b);
			}
			case 5: // local_variable_declaration_statement = local_variable_declaration.l SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final VarDeclStmt l = (VarDeclStmt) _symbol_l.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return l;
			}
			case 6: // local_variable_declaration = type.t IDENTIFIER.IDENTIFIER
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					 return new VarDeclStmt(l++, t, IDENTIFIER);
			}
			case 7: // type = BYTE.BYTE
			{
					final Symbol BYTE = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("byte");
			}
			case 8: // type = SHORT.SHORT
			{
					final Symbol SHORT = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("short");
			}
			case 9: // type = INT.INT
			{
					final Symbol INT = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("int");
			}
			case 10: // type = LONG.LONG
			{
					final Symbol LONG = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("long");
			}
			case 11: // type = CHAR.CHAR
			{
					final Symbol CHAR = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("char");
			}
			case 24: // for_statement = FOR.FOR LPAREN.LPAREN for_init_opt.i SEMICOLON.SEMICOLON expression_opt.e SEMICOLON.SEMICOLON_ for_update_opt.u RPAREN.RPAREN statement.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol SEMICOLON = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Opt e = (Opt) _symbol_e.value;
					final Symbol SEMICOLON_ = _symbols[offset + 6];
					final Symbol _symbol_u = _symbols[offset + 7];
					final List u = (List) _symbol_u.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_s = _symbols[offset + 9];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(l++, i, e, u, s);
			}
			case 27: // statement_expression_list = statement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final ExprStmt e = (ExprStmt) _symbol_e.value;
					 return new List().add(e);
			}
			case 28: // statement_expression_list = statement_expression_list.l COMMA.COMMA statement_expression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final ExprStmt e = (ExprStmt) _symbol_e.value;
					 return l.add(e);
			}
			case 29: // statement_expression = assignment.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new ExprStmt(l++, a);
			}
			case 30: // statement_expression = preincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(l++, e);
			}
			case 31: // statement_expression = predecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(l++, e);
			}
			case 32: // statement_expression = postincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(l++, e);
			}
			case 33: // statement_expression = postdecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(l++, e);
			}
			case 34: // while_statement = WHILE.WHILE LPAREN.LPAREN expression.e RPAREN.RPAREN statement.s
			{
					final Symbol WHILE = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new WhileStmt(l++, e, s);
			}
			case 35: // if_then_else_statement = IF.IF LPAREN.LPAREN expression.e RPAREN.RPAREN statement.t ELSE.ELSE statement.els
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_t = _symbols[offset + 5];
					final Stmt t = (Stmt) _symbol_t.value;
					final Symbol ELSE = _symbols[offset + 6];
					final Symbol _symbol_els = _symbols[offset + 7];
					final Stmt els = (Stmt) _symbol_els.value;
					 return new IfStmt(l++, e, t, els);
			}
			case 36: // labeled_statement = IDENTIFIER.id COLON.COLON statement.s
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol COLON = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new LabeledStmt(l++, ((String)id.value), s);
			}
			case 37: // goto_statement = GOTO.GOTO IDENTIFIER.id SEMICOLON.SEMICOLON
			{
					final Symbol GOTO = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new GotoStmt(l++, ((String)id.value));
			}
			case 38: // continue_statement = CONTINUE.CONTINUE IDENTIFIER.id SEMICOLON.SEMICOLON
			{
					final Symbol CONTINUE = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new ContinueStmt(l++, ((String)id.value));
			}
			case 39: // continue_statement = CONTINUE.CONTINUE SEMICOLON.SEMICOLON
			{
					final Symbol CONTINUE = _symbols[offset + 1];
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new ContinueStmt(l++, "");
			}
			case 40: // break_statement = BREAK.BREAK IDENTIFIER.id SEMICOLON.SEMICOLON
			{
					final Symbol BREAK = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new BreakStmt(l++, ((String)id.value));
			}
			case 41: // break_statement = BREAK.BREAK SEMICOLON.SEMICOLON
			{
					final Symbol BREAK = _symbols[offset + 1];
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new BreakStmt(l++, "");
			}
			case 42: // do_statement = DO.DO statement.s WHILE.WHILE LPAREN.LPAREN expression.e RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol DO = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 2];
					final Stmt s = (Stmt) _symbol_s.value;
					final Symbol WHILE = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol SEMICOLON = _symbols[offset + 7];
					 return new DoStmt(l++, s, e);
			}
			case 43: // expression_statement = statement_expression.e SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final ExprStmt e = (ExprStmt) _symbol_e.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return e;
			}
			case 44: // empty_statement = SEMICOLON.SEMICOLON
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					 return new EmptyStmt(l++);
			}
			case 48: // assignment = postfix_expression.dest EQ.EQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol EQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignSimpleExpr(dest, source);
			}
			case 49: // assignment = postfix_expression.dest MULTEQ.MULTEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol MULTEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignMulExpr(dest, source);
			}
			case 50: // assignment = postfix_expression.dest DIVEQ.DIVEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol DIVEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignDivExpr(dest, source);
			}
			case 51: // assignment = postfix_expression.dest MODEQ.MODEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol MODEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignModExpr(dest, source);
			}
			case 52: // assignment = postfix_expression.dest PLUSEQ.PLUSEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol PLUSEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignPlusExpr(dest, source);
			}
			case 53: // assignment = postfix_expression.dest MINUSEQ.MINUSEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol MINUSEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignMinusExpr(dest, source);
			}
			case 54: // assignment = postfix_expression.dest LSHIFTEQ.LSHIFTEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol LSHIFTEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignLShiftExpr(dest, source);
			}
			case 55: // assignment = postfix_expression.dest RSHIFTEQ.RSHIFTEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol RSHIFTEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignRShiftExpr(dest, source);
			}
			case 56: // assignment = postfix_expression.dest ANDEQ.ANDEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol ANDEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignAndExpr(dest, source);
			}
			case 57: // assignment = postfix_expression.dest XOREQ.XOREQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol XOREQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignXorExpr(dest, source);
			}
			case 58: // assignment = postfix_expression.dest OREQ.OREQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol OREQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignOrExpr(dest, source);
			}
			case 63: // literal = INTEGER_LITERAL.INTEGER_LITERAL
			{
					final Symbol INTEGER_LITERAL = _symbols[offset + 1];
					 return new IntegerLiteral(INTEGER_LITERAL);
			}
			case 64: // literal = LONG_LITERAL.LONG_LITERAL
			{
					final Symbol LONG_LITERAL = _symbols[offset + 1];
					 return new LongLiteral(LONG_LITERAL);
			}
			case 65: // literal = FLOATING_POINT_LITERAL.FLOATING_POINT_LITERAL
			{
					final Symbol FLOATING_POINT_LITERAL = _symbols[offset + 1];
					 return new FloatingPointLiteral(FLOATING_POINT_LITERAL);
			}
			case 66: // literal = DOUBLE_LITERAL.DOUBLE_LITERAL
			{
					final Symbol DOUBLE_LITERAL = _symbols[offset + 1];
					 return new DoubleLiteral(DOUBLE_LITERAL);
			}
			case 67: // literal = CHARACTER_LITERAL.CHARACTER_LITERAL
			{
					final Symbol CHARACTER_LITERAL = _symbols[offset + 1];
					 return new CharacterLiteral(CHARACTER_LITERAL);
			}
			case 68: // literal = STRING_LITERAL.STRING_LITERAL
			{
					final Symbol STRING_LITERAL = _symbols[offset + 1];
					 return new StringLiteral(STRING_LITERAL);
			}
			case 69: // postincrement_expression = postfix_expression.e PLUSPLUS.PLUSPLUS
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol PLUSPLUS = _symbols[offset + 2];
					 return new PostIncExpr(e);
			}
			case 70: // postdecrement_expression = postfix_expression.e MINUSMINUS.MINUSMINUS
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol MINUSMINUS = _symbols[offset + 2];
					 return new PostDecExpr(e);
			}
			case 72: // simple_name = IDENTIFIER.IDENTIFIER
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					 return new ParseName(IDENTIFIER);
			}
			case 74: // multiplicative_expression = multiplicative_expression.e1 MULT.MULT unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MULT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new MulExpr(e1, e2);
			}
			case 75: // multiplicative_expression = multiplicative_expression.e1 DIV.DIV unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol DIV = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new DivExpr(e1, e2);
			}
			case 76: // multiplicative_expression = multiplicative_expression.e1 MOD.MOD unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MOD = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ModExpr(e1, e2);
			}
			case 78: // additive_expression = additive_expression.e1 PLUS.PLUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol PLUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AddExpr(e1, e2);
			}
			case 79: // additive_expression = additive_expression.e1 MINUS.MINUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MINUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new SubExpr(e1, e2);
			}
			case 81: // shift_expression = shift_expression.e1 LSHIFT.LSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LShiftExpr(e1, e2);
			}
			case 82: // shift_expression = shift_expression.e1 RSHIFT.RSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol RSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new RShiftExpr(e1, e2);
			}
			case 84: // relational_expression = relational_expression.e1 LT.LT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LTExpr(e1, e2);
			}
			case 85: // relational_expression = relational_expression.e1 GT.GT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol GT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GTExpr(e1, e2);
			}
			case 86: // relational_expression = relational_expression.e1 LTEQ.LTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LEExpr(e1, e2);
			}
			case 87: // relational_expression = relational_expression.e1 GTEQ.GTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol GTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GEExpr(e1, e2);
			}
			case 89: // equality_expression = equality_expression.e1 EQEQ.EQEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol EQEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new EQExpr(e1, e2);
			}
			case 90: // equality_expression = equality_expression.e1 NOTEQ.NOTEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol NOTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new NEExpr(e1, e2);
			}
			case 92: // and_expression = and_expression.e1 AND.AND equality_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol AND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndBitwiseExpr(e1, e2);
			}
			case 94: // exclusive_or_expression = exclusive_or_expression.e1 XOR.XOR and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol XOR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new XorBitwiseExpr(e1, e2);
			}
			case 96: // inclusive_or_expression = inclusive_or_expression.e1 OR.OR exclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol OR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrBitwiseExpr(e1, e2);
			}
			case 98: // conditional_and_expression = conditional_and_expression.e1 ANDAND.ANDAND inclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol ANDAND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndLogicalExpr(e1, e2);
			}
			case 100: // conditional_or_expression = conditional_or_expression.e1 OROR.OROR conditional_and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol OROR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrLogicalExpr(e1, e2);
			}
			case 102: // conditional_expression = conditional_or_expression.c QUESTION.QUESTION expression.e1 COLON.COLON conditional_expression.e2
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					final Symbol QUESTION = _symbols[offset + 2];
					final Symbol _symbol_e1 = _symbols[offset + 3];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol COLON = _symbols[offset + 4];
					final Symbol _symbol_e2 = _symbols[offset + 5];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ConditionalExpr(c, e1, e2);
			}
			case 105: // unary_expression = PLUS.PLUS unary_expression.e
			{
					final Symbol PLUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new PlusExpr(e);
			}
			case 106: // unary_expression = MINUS.MINUS unary_expression.e
			{
					final Symbol MINUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new MinusExpr(e);
			}
			case 108: // preincrement_expression = PLUSPLUS.PLUSPLUS unary_expression.e
			{
					final Symbol PLUSPLUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new PreIncExpr(e);
			}
			case 109: // predecrement_expression = MINUSMINUS.MINUSMINUS unary_expression.e
			{
					final Symbol MINUSMINUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new PreDecExpr(e);
			}
			case 111: // unary_expression_not_plus_minus = COMP.COMP unary_expression.e
			{
					final Symbol COMP = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new BitNotExpr(e);
			}
			case 112: // unary_expression_not_plus_minus = NOT.NOT unary_expression.e
			{
					final Symbol NOT = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new LogNotExpr(e);
			}
			case 113: // for_init_opt = 
			{
					 return new List();
			}
			case 114: // for_init_opt = for_init.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 115: // for_update_opt = 
			{
					 return new List();
			}
			case 116: // for_update_opt = for_update.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 117: // block_statements_opt = 
			{
					 return new List();
			}
			case 118: // block_statements_opt = block_statements.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 119: // expression_opt = 
			{
					 return new Opt();
			}
			case 120: // expression_opt = expression.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Expr n = (Expr) _symbol_n.value;
					 return new Opt(n);
			}
			case 4: // block_statement = statement.statement
			case 12: // statement = labeled_statement.labeled_statement
			case 13: // statement = if_then_else_statement.if_then_else_statement
			case 14: // statement = while_statement.while_statement
			case 15: // statement = for_statement.for_statement
			case 16: // statement = expression_statement.expression_statement
			case 17: // statement = block.block
			case 18: // statement = empty_statement.empty_statement
			case 19: // statement = do_statement.do_statement
			case 20: // statement = break_statement.break_statement
			case 21: // statement = continue_statement.continue_statement
			case 22: // statement = local_variable_declaration_statement.local_variable_declaration_statement
			case 23: // statement = goto_statement.goto_statement
			case 25: // for_init = statement_expression_list.statement_expression_list
			case 26: // for_update = statement_expression_list.statement_expression_list
			case 45: // expression = assignment_expression.assignment_expression
			case 46: // assignment_expression = conditional_expression.conditional_expression
			case 47: // assignment_expression = assignment.assignment
			case 59: // postfix_expression = literal.literal
			case 60: // postfix_expression = name.name
			case 61: // postfix_expression = postincrement_expression.postincrement_expression
			case 62: // postfix_expression = postdecrement_expression.postdecrement_expression
			case 71: // name = simple_name.simple_name
			case 73: // multiplicative_expression = unary_expression.unary_expression
			case 77: // additive_expression = multiplicative_expression.multiplicative_expression
			case 80: // shift_expression = additive_expression.additive_expression
			case 83: // relational_expression = shift_expression.shift_expression
			case 88: // equality_expression = relational_expression.relational_expression
			case 91: // and_expression = equality_expression.equality_expression
			case 93: // exclusive_or_expression = and_expression.and_expression
			case 95: // inclusive_or_expression = exclusive_or_expression.exclusive_or_expression
			case 97: // conditional_and_expression = inclusive_or_expression.inclusive_or_expression
			case 99: // conditional_or_expression = conditional_and_expression.conditional_and_expression
			case 101: // conditional_expression = conditional_or_expression.conditional_or_expression
			case 103: // unary_expression = preincrement_expression.preincrement_expression
			case 104: // unary_expression = predecrement_expression.predecrement_expression
			case 107: // unary_expression = unary_expression_not_plus_minus.unary_expression_not_plus_minus
			case 110: // unary_expression_not_plus_minus = postfix_expression.postfix_expression
			{
				return _symbols[offset + 1];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
