// Generated from parser/picoC.parser
package AST;
import AST.*; 
import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "PicoCParser.beaver".
 */
public class PicoCParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short SEMICOLON = 1;
		static public final short RPAREN = 2;
		static public final short COMMA = 3;
		static public final short PLUS = 4;
		static public final short MINUS = 5;
		static public final short PLUSPLUS = 6;
		static public final short MINUSMINUS = 7;
		static public final short COLON = 8;
		static public final short IDENTIFIER = 9;
		static public final short QUESTION = 10;
		static public final short OROR = 11;
		static public final short ANDAND = 12;
		static public final short INTEGER_LITERAL = 13;
		static public final short LONG_LITERAL = 14;
		static public final short FLOATING_POINT_LITERAL = 15;
		static public final short DOUBLE_LITERAL = 16;
		static public final short CHARACTER_LITERAL = 17;
		static public final short STRING_LITERAL = 18;
		static public final short OR = 19;
		static public final short XOR = 20;
		static public final short AND = 21;
		static public final short EQEQ = 22;
		static public final short NOTEQ = 23;
		static public final short LT = 24;
		static public final short GT = 25;
		static public final short LTEQ = 26;
		static public final short GTEQ = 27;
		static public final short COMP = 28;
		static public final short NOT = 29;
		static public final short LSHIFT = 30;
		static public final short RSHIFT = 31;
		static public final short WHILE = 32;
		static public final short MULT = 33;
		static public final short DIV = 34;
		static public final short MOD = 35;
		static public final short RBRACE = 36;
		static public final short ELSE = 37;
		static public final short EQ = 38;
		static public final short MULTEQ = 39;
		static public final short DIVEQ = 40;
		static public final short MODEQ = 41;
		static public final short PLUSEQ = 42;
		static public final short MINUSEQ = 43;
		static public final short LSHIFTEQ = 44;
		static public final short RSHIFTEQ = 45;
		static public final short ANDEQ = 46;
		static public final short XOREQ = 47;
		static public final short OREQ = 48;
		static public final short LBRACE = 49;
		static public final short FOR = 50;
		static public final short DO = 51;
		static public final short IF = 52;
		static public final short GOTO = 53;
		static public final short CONTINUE = 54;
		static public final short BREAK = 55;
		static public final short BYTE = 56;
		static public final short SHORT = 57;
		static public final short INT = 58;
		static public final short LONG = 59;
		static public final short CHAR = 60;
		static public final short LPAREN = 61;

		static public final String[] NAMES = {
			"EOF",
			"SEMICOLON",
			"RPAREN",
			"COMMA",
			"PLUS",
			"MINUS",
			"PLUSPLUS",
			"MINUSMINUS",
			"COLON",
			"IDENTIFIER",
			"QUESTION",
			"OROR",
			"ANDAND",
			"INTEGER_LITERAL",
			"LONG_LITERAL",
			"FLOATING_POINT_LITERAL",
			"DOUBLE_LITERAL",
			"CHARACTER_LITERAL",
			"STRING_LITERAL",
			"OR",
			"XOR",
			"AND",
			"EQEQ",
			"NOTEQ",
			"LT",
			"GT",
			"LTEQ",
			"GTEQ",
			"COMP",
			"NOT",
			"LSHIFT",
			"RSHIFT",
			"WHILE",
			"MULT",
			"DIV",
			"MOD",
			"RBRACE",
			"ELSE",
			"EQ",
			"MULTEQ",
			"DIVEQ",
			"MODEQ",
			"PLUSEQ",
			"MINUSEQ",
			"LSHIFTEQ",
			"RSHIFTEQ",
			"ANDEQ",
			"XOREQ",
			"OREQ",
			"LBRACE",
			"FOR",
			"DO",
			"IF",
			"GOTO",
			"CONTINUE",
			"BREAK",
			"BYTE",
			"SHORT",
			"INT",
			"LONG",
			"CHAR",
			"LPAREN"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjMmdSLMCUVkwztrVVtenX22d96X7PYHJILv64LB9bYJ1ZnimOwrZ6KfRIzeM8b6ZHAeM" +
		"IiUzR8Go696k5cJ7ZdUV$F#yvzxtdt7E$UygM#Uxp#z$$#$xVvttUvRndlVS0JUhC0xb0ng" +
		"RUKxohU2223p1VlR6rcg8q3qimFnVOnARUKVn3CJ$2QeR6wblOV4ji6MKf7ii5jhQfznM3i" +
		"ItQX3d4Vx2piblRMhiWdOSbU3GNsDMchZBBg38Vk#7AC8VuBsvNzXssrWJScOSb#5ikS9Vr" +
		"T#CUgimm$pR$2dE8VvglrNzbyr#QQ$Em18#4SBNrroFuH3YF#56$B3zBiIWNv5dlw2#Aiho" +
		"eouwo50$dWZph7Vs7eomlwhAZBCN2N91dlQE$CChoeYuxob8io0LvrZlw2w8iB#goeop5Gx" +
		"aWptf7$w4eoukwx2XByM0koBFUqNymolAYBZlAKipB1NdME$hpeYmlwhAZBCNzkI3FUaV$$" +
		"YZBYxhiA4jnem$qGLz#m#PS$Hl3yACvxC6u5jTZA6x428n27Mx2BRWLCp45Kp4Dz#9ud83J" +
		"SIIE9lSCscJQ09oCKt0gJiD0rTW1DNWO4p4TvQX09QfGZIRu1Nw9zV0hhEzqgX5Amjhc5e6" +
		"MKbjIcj$NrX3jiWBQORMnWa1jh1Y$NRKD4wZTB0ZK97K5zZRVcc#PMwrgcoPGUrd0cjzYib" +
		"dDD7NeLvjLZArKjSqIgBqaOCrLL5l9z2fY9NMo8zsYWDerE1I7uKISPBVmRz0BlyCVS27sn" +
		"2Nu2ox5PRWSLsClx87T8stV90ZcvIR8Flq5jZ6V1srlN$n8T5r#GVkS8$c2#DpJCPy5QctZ" +
		"rUBs1LkRAaJylh1ZaFVM#0Ps$jmrVapiN3NNkJh038dXT446hR0JDi8aZCSupC9ipC5zc9j" +
		"i$isBYhyBsEyNzLpjVZPEg9VthEteRPvmVSJEaFcKx4vebx1$BmWuqa#n8xzVC9yovMwVlz" +
		"QxVRfootw2vkRZx9OrAo9R5h7RfpbhGsgRJuYFYHNcRSKAGgvEucfAZvyN1Eq#7sut$rMDr" +
		"6IxhvXNicDbkkWU5rYdm445QagFdnC4FNwkg7tW7A$7oetVUzQqnnSNxh7z#3t#Y6DOdcYl" +
		"pQwugyn7PYbhW$uZivofc7RDJ1zw$9WffbXgZpLBYPbXU5prtJ08PvdxV6Z9VMAADxCxO9Q" +
		"JotNOOtneoHZpfis$wUcOjpGQWkME2ShgV6X9dPZYBTkFjuYwC3okmnxjGqj6Yoa#T4OqEW" +
		"m$6fIDyg4beyo7Dl#XfsCMQpG4onqLb8tqeIKZnHIBRJyM4oF3yBWEUuGFBHaXfdZL6T68C" +
		"FneK3RSXvOCDw$Q$AkUZbcYqH0iTtXGDio7bWmJKoon$LX230l3uphieJwqPAYOuZLdH4F3" +
		"yAD1sHmVMZB7l6RphtawvdMDXc2vSuAosJwqPBQOudNRZzU9sM5uN8SzruUMp1LJVEECQ6u" +
		"OVZGec#53IsQORsp#6q$7lA7H42ntHh1Fp$AX9RF456$OVhn1p0h3uwfNbKHdoI69sDSbOj" +
		"#GY3qi4Nju8lR8HEpHYTXZ4h5lJiGUcuXzcxbNW5hyLjV4lM8QSJvUn4KGdIO8QayJquXRU" +
		"reOGNIw8AWzNKmZRktfOVZHWkVmx3ZtAOhNtamH1ArE4NCZNZGC3H#2tvl9We0dzoOv4IyQ" +
		"Hb3x7a70kqVCZNZHC8BQTmi2tjrYRiIBXX7KdYe8U5F5t8WN3SElNSJSxc$k4WHQTucv4I$" +
		"g0mVZZpWFvvk9Wg1yefWRyQ8#WbgJ5F8CuzSidoGcoAaroKTGwrb1KFvipBEFQxIu1tewJo" +
		"Na4tugaSleX$u96T6xL678PtAUiWVD7GBOjSOKR8Hb6bg8hJJVaUa5B7r6yRG0yympZ6x7b" +
		"7pk$m56jyump5E2O5KyPHbnAxvpmzpzF1dcIK6m3fwiPntygV0wC4y80hKdwb7xSprgZmi2" +
		"jSVhKRkWOOskaum#w5k4Hkx7FsV89##pTdEd85WxTugv4I#gaGDnKSoQEjTC40Jy2M9kn8j" +
		"gX2hcXY0OlwQlguyHwKjtzYKSEpnFx8WyiQFon7hdYHsR9tPSdjYPUM9devSPBmXcPBoO6$" +
		"6Yp7UCFFCU9r22N5UE4miYm0DQSnmwcDi5WTRjObx4t2gmqGwIyYBcDe6ji9#aSY8sZXJIo" +
		"A04fMY4nYX3M$iqt8jxt$9qVGDUSss8ZT0K6sCJZMwcp#WsHqjiWNtH2bjXQso3RR4TMcDx" +
		"x80ss14xHVJJHUbloHBHtzVgfvagJZ#Lez#AFfL7FuKMgfyE#dzamlwVoP9MEeAolFhbgf#" +
		"o#f9FrlzorI$Ncb7zSgjVRlNBgP9mVapmYUfhbFhyLdtD5wLFdkeRqw3VeD#WlzRwxNcCtX" +
		"yTS03F7PrubcKhv9RJQcdLgF5$jLIDNZoE7SKpQs#UfUIweX$FRFrv9fDp3SzOJfy6yimLr" +
		"jQnQAbeXyPId$QFeWOvZh5i3TLu5gYbbV58kwNQTwgsXYCz20VpVlCGTA5QLtJZzOzSR$JW" +
		"DKzFNkFKCoyOe2CurJk#9srRwxIm8t56KQHQpBuWYbfV56Ft1VzSoLomnhNCMUC5vgg5dQj" +
		"MiPoss1cxe1rsnMxO7NjWJ#o5lR5FmlbthbjqlhMlpdur8A5Uthr#BVJYsIbb9zNBhksKZb" +
		"UseRDzg5V$zadfzLOgksNjUievUiLkdnRUYhJhHwn5S7MdVOcjwUtDmlJRBOkig9YZkZTYr" +
		"iqURyiIz3XsZbchQu6QnVGuPewzEIgqztnVFROjETkMOqYsrsPNdCowkwrZs$MFDTfsmcED" +
		"VzwDLKbqTHnMuHWy5UVekHPzQHXHmuWQHlH3Z#YxEkisiDSrTipwCQQOjVoZrYvu3dV6MHm" +
		"lkBDOyv7y7zOkPcxNg8MrgHNSZwrXM$5NoIorzticvfeppC2cQ9QC4RrB5ORMgyrJrikEkJ" +
		"OwK#Yb4VcjGSVCz1d6l#BslazM$cdskdlGzp#wTOUHPmKA8$xesZ1tFql6TxiEVifgFvKPR" +
		"s24Lg2Sp#hLoFtuvmnD5tYMdxDs2fqhuzPKCfN8yvCyQpfTBoDVNtxgiUBdAU4l2q7Ds1OS" +
		"1U4vzwlP6Yo9wnEmw6BvlTtel$#R0oMTl9$JC$AlZ5gWLDvEF8$vusbNqAwaBQUj87Szscf" +
		"oTgQre#q5DDg6jXrGyGdpRPdkJEqFWCesrDcDiK7qMz5VpJ8QjpWgzuFyimIbZp8c$zdT4A" +
		"YHjrzFOLap#hEObtU4BY3dFN9MCNqsq7XZMb$cvTTxUdc7ft8mlRndC9Pbbv8$X7sL$jz6w" +
		"ydoc#bBwQS0JHYlP3jDUjDJl$8qsZjiwtBwbHp3NA0gGrz5pp6LS#nLUxEzFlHTwI#aKRVH" +
		"8ypterz6VoRRhQ3jmFH5z8VHNqz$3kVAk$U7l9rJnNgDsS#gwVJodtkPR$b7YOpxCo35CQK" +
		"EfL4ZDPNsDf1kGkDSfJaVLOjORodzo$JKB6l9zFlq1z9EPVehzdS2ZNDQtPXZQ4tFRL3HXR" +
		"uNFSTQmV5KdqzFZGgsMJEHSx4FZTke2RTrDUSEe#bluPon$SpsR9lpMit#b8oaNy3vPP#gN" +
		"w1ddwhVfN#SdjkdadDGKq9$2Vq6z9VHSxjNCLspEpbDwJlJxq$F#Q$cjeRyAuJRfR6yQIV$" +
		"$9MvaVVJ7kEOPFt86#bFCyt#wozcDJHkZv8wjdiCqnmhdcDOokK$PY$INgB9koJovWJxnxi" +
		"2f2NUdYR$I$sQ9kynoDkQaoxs5dyRpwU7YlUD#GLkFecnxh9ikgIZvpCrrk$gb9rkOtspiS" +
		"hrRUnIcszfytNHTZ8B7QrXXVjKFj7w#Pwl66ZhDRNUpaVf8DlkUpRUslhbdgyPdwjRCzNwk" +
		"KviaVNFHFjHizZwTmhrDtuSDIki$p8RAntZbFVFfgkMURxQpdsrC$UbZyQtKJBFSbRdnikw" +
		"Mp$0#lEj7sQzdSEoXTOliVuppvStihwPzUsIZdzjZFlv#l5b#ZbN$nzq9Eyd1z8Ff3#HPvQ" +
		"ZQRsP3zjH2QqVod46$I3QoMePlUiDMrzU8VNXbT8nB3#9TWBjUDfnZ1tBllGdPm3j26krSj" +
		"TSfBKdtxMECTQ1xHn0wyIqdBaxgsK2a#kbGzHdz3VABkepwAg$LsPoh1jZtTHdq9tfxlJoD" +
		"ELGUdbUTHXz3$eUz8VJ7qxVaxudv#4WUi$IrbAygaZpkYAjro87gq$BsPEM0e$qj9GUxKxN" +
		"NzGXlwhZhFy1KVqKaW==");
 // Generated from parser/picoC.parser
int l = 1; // l means label

	public PicoCParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // goal = block.block
			{
					final Symbol _symbol_block = _symbols[offset + 1];
					final Stmt block = (Stmt) _symbol_block.value;
					 return new Program(block);
			}
			case 1: // block = LBRACE.LBRACE block_statements_opt.list RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_list = _symbols[offset + 2];
					final List list = (List) _symbol_list.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new Block(l++, list);
			}
			case 2: // block_statements = statement.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Stmt b = (Stmt) _symbol_b.value;
					 return new List().add(b);
			}
			case 3: // block_statements = block_statements.l SEMICOLON.SEMICOLON statement.b
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Stmt b = (Stmt) _symbol_b.value;
					 return l.add(b);
			}
			case 4: // local_variable_declaration_statement = local_variable_declaration.l SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final VarDeclStmt l = (VarDeclStmt) _symbol_l.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return l;
			}
			case 5: // local_variable_declaration = type.t IDENTIFIER.IDENTIFIER
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol IDENTIFIER = _symbols[offset + 2];
					 return new VarDeclStmt(l++, t, IDENTIFIER);
			}
			case 6: // type = BYTE.BYTE
			{
					final Symbol BYTE = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("byte");
			}
			case 7: // type = SHORT.SHORT
			{
					final Symbol SHORT = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("short");
			}
			case 8: // type = INT.INT
			{
					final Symbol INT = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("int");
			}
			case 9: // type = LONG.LONG
			{
					final Symbol LONG = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("long");
			}
			case 10: // type = CHAR.CHAR
			{
					final Symbol CHAR = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("char");
			}
			case 23: // for_statement = FOR.FOR LPAREN.LPAREN for_init_opt.i SEMICOLON.SEMICOLON expression_opt.e SEMICOLON.SEMICOLON_ for_update_opt.u RPAREN.RPAREN statement.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol SEMICOLON = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Opt e = (Opt) _symbol_e.value;
					final Symbol SEMICOLON_ = _symbols[offset + 6];
					final Symbol _symbol_u = _symbols[offset + 7];
					final List u = (List) _symbol_u.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_s = _symbols[offset + 9];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(l++, i, e, u, s);
			}
			case 26: // statement_expression_list = statement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final ExprStmt e = (ExprStmt) _symbol_e.value;
					 return new List().add(e);
			}
			case 27: // statement_expression_list = statement_expression_list.l COMMA.COMMA statement_expression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final ExprStmt e = (ExprStmt) _symbol_e.value;
					 return l.add(e);
			}
			case 28: // statement_expression = assignment.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new ExprStmt(l++, a);
			}
			case 29: // statement_expression = preincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(l++, e);
			}
			case 30: // statement_expression = predecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(l++, e);
			}
			case 31: // statement_expression = postincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(l++, e);
			}
			case 32: // statement_expression = postdecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(l++, e);
			}
			case 33: // while_statement = WHILE.WHILE LPAREN.LPAREN expression.e RPAREN.RPAREN statement.s
			{
					final Symbol WHILE = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new WhileStmt(l++, e, s);
			}
			case 34: // if_then_else_statement = IF.IF LPAREN.LPAREN expression.e RPAREN.RPAREN statement.t ELSE.ELSE statement.els
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_t = _symbols[offset + 5];
					final Stmt t = (Stmt) _symbol_t.value;
					final Symbol ELSE = _symbols[offset + 6];
					final Symbol _symbol_els = _symbols[offset + 7];
					final Stmt els = (Stmt) _symbol_els.value;
					 return new IfStmt(l++, e, t, els);
			}
			case 35: // labeled_statement = IDENTIFIER.id COLON.COLON statement.s
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol COLON = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new LabeledStmt(l++, ((String)id.value), s);
			}
			case 36: // goto_statement = GOTO.GOTO IDENTIFIER.id SEMICOLON.SEMICOLON
			{
					final Symbol GOTO = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new GotoStmt(l++, ((String)id.value));
			}
			case 37: // continue_statement = CONTINUE.CONTINUE IDENTIFIER.id SEMICOLON.SEMICOLON
			{
					final Symbol CONTINUE = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new ContinueStmt(l++, ((String)id.value));
			}
			case 38: // break_statement = BREAK.BREAK IDENTIFIER.id SEMICOLON.SEMICOLON
			{
					final Symbol BREAK = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new BreakStmt(l++, ((String)id.value));
			}
			case 39: // do_statement = DO.DO statement.s WHILE.WHILE LPAREN.LPAREN expression.e RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol DO = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 2];
					final Stmt s = (Stmt) _symbol_s.value;
					final Symbol WHILE = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol SEMICOLON = _symbols[offset + 7];
					 return new DoStmt(l++, s, e);
			}
			case 40: // expression_statement = statement_expression.e SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final ExprStmt e = (ExprStmt) _symbol_e.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return e;
			}
			case 41: // empty_statement = SEMICOLON.SEMICOLON
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					 return new EmptyStmt(l++);
			}
			case 45: // assignment = postfix_expression.dest EQ.EQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol EQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignSimpleExpr(dest, source);
			}
			case 46: // assignment = postfix_expression.dest MULTEQ.MULTEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol MULTEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignMulExpr(dest, source);
			}
			case 47: // assignment = postfix_expression.dest DIVEQ.DIVEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol DIVEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignDivExpr(dest, source);
			}
			case 48: // assignment = postfix_expression.dest MODEQ.MODEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol MODEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignModExpr(dest, source);
			}
			case 49: // assignment = postfix_expression.dest PLUSEQ.PLUSEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol PLUSEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignPlusExpr(dest, source);
			}
			case 50: // assignment = postfix_expression.dest MINUSEQ.MINUSEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol MINUSEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignMinusExpr(dest, source);
			}
			case 51: // assignment = postfix_expression.dest LSHIFTEQ.LSHIFTEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol LSHIFTEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignLShiftExpr(dest, source);
			}
			case 52: // assignment = postfix_expression.dest RSHIFTEQ.RSHIFTEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol RSHIFTEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignRShiftExpr(dest, source);
			}
			case 53: // assignment = postfix_expression.dest ANDEQ.ANDEQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol ANDEQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignAndExpr(dest, source);
			}
			case 54: // assignment = postfix_expression.dest XOREQ.XOREQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol XOREQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignXorExpr(dest, source);
			}
			case 55: // assignment = postfix_expression.dest OREQ.OREQ assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol OREQ = _symbols[offset + 2];
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 return new AssignOrExpr(dest, source);
			}
			case 60: // literal = INTEGER_LITERAL.INTEGER_LITERAL
			{
					final Symbol INTEGER_LITERAL = _symbols[offset + 1];
					 return new IntegerLiteral(INTEGER_LITERAL);
			}
			case 61: // literal = LONG_LITERAL.LONG_LITERAL
			{
					final Symbol LONG_LITERAL = _symbols[offset + 1];
					 return new LongLiteral(LONG_LITERAL);
			}
			case 62: // literal = FLOATING_POINT_LITERAL.FLOATING_POINT_LITERAL
			{
					final Symbol FLOATING_POINT_LITERAL = _symbols[offset + 1];
					 return new FloatingPointLiteral(FLOATING_POINT_LITERAL);
			}
			case 63: // literal = DOUBLE_LITERAL.DOUBLE_LITERAL
			{
					final Symbol DOUBLE_LITERAL = _symbols[offset + 1];
					 return new DoubleLiteral(DOUBLE_LITERAL);
			}
			case 64: // literal = CHARACTER_LITERAL.CHARACTER_LITERAL
			{
					final Symbol CHARACTER_LITERAL = _symbols[offset + 1];
					 return new CharacterLiteral(CHARACTER_LITERAL);
			}
			case 65: // literal = STRING_LITERAL.STRING_LITERAL
			{
					final Symbol STRING_LITERAL = _symbols[offset + 1];
					 return new StringLiteral(STRING_LITERAL);
			}
			case 66: // postincrement_expression = postfix_expression.e PLUSPLUS.PLUSPLUS
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol PLUSPLUS = _symbols[offset + 2];
					 return new PostIncExpr(e);
			}
			case 67: // postdecrement_expression = postfix_expression.e MINUSMINUS.MINUSMINUS
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol MINUSMINUS = _symbols[offset + 2];
					 return new PostDecExpr(e);
			}
			case 69: // simple_name = IDENTIFIER.IDENTIFIER
			{
					final Symbol IDENTIFIER = _symbols[offset + 1];
					 return new ParseName(IDENTIFIER);
			}
			case 71: // multiplicative_expression = multiplicative_expression.e1 MULT.MULT unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MULT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new MulExpr(e1, e2);
			}
			case 72: // multiplicative_expression = multiplicative_expression.e1 DIV.DIV unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol DIV = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new DivExpr(e1, e2);
			}
			case 73: // multiplicative_expression = multiplicative_expression.e1 MOD.MOD unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MOD = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ModExpr(e1, e2);
			}
			case 75: // additive_expression = additive_expression.e1 PLUS.PLUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol PLUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AddExpr(e1, e2);
			}
			case 76: // additive_expression = additive_expression.e1 MINUS.MINUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MINUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new SubExpr(e1, e2);
			}
			case 78: // shift_expression = shift_expression.e1 LSHIFT.LSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LShiftExpr(e1, e2);
			}
			case 79: // shift_expression = shift_expression.e1 RSHIFT.RSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol RSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new RShiftExpr(e1, e2);
			}
			case 81: // relational_expression = relational_expression.e1 LT.LT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LTExpr(e1, e2);
			}
			case 82: // relational_expression = relational_expression.e1 GT.GT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol GT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GTExpr(e1, e2);
			}
			case 83: // relational_expression = relational_expression.e1 LTEQ.LTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LEExpr(e1, e2);
			}
			case 84: // relational_expression = relational_expression.e1 GTEQ.GTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol GTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GEExpr(e1, e2);
			}
			case 86: // equality_expression = equality_expression.e1 EQEQ.EQEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol EQEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new EQExpr(e1, e2);
			}
			case 87: // equality_expression = equality_expression.e1 NOTEQ.NOTEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol NOTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new NEExpr(e1, e2);
			}
			case 89: // and_expression = and_expression.e1 AND.AND equality_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol AND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndBitwiseExpr(e1, e2);
			}
			case 91: // exclusive_or_expression = exclusive_or_expression.e1 XOR.XOR and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol XOR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new XorBitwiseExpr(e1, e2);
			}
			case 93: // inclusive_or_expression = inclusive_or_expression.e1 OR.OR exclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol OR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrBitwiseExpr(e1, e2);
			}
			case 95: // conditional_and_expression = conditional_and_expression.e1 ANDAND.ANDAND inclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol ANDAND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndLogicalExpr(e1, e2);
			}
			case 97: // conditional_or_expression = conditional_or_expression.e1 OROR.OROR conditional_and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol OROR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrLogicalExpr(e1, e2);
			}
			case 99: // conditional_expression = conditional_or_expression.c QUESTION.QUESTION expression.e1 COLON.COLON conditional_expression.e2
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					final Symbol QUESTION = _symbols[offset + 2];
					final Symbol _symbol_e1 = _symbols[offset + 3];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol COLON = _symbols[offset + 4];
					final Symbol _symbol_e2 = _symbols[offset + 5];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ConditionalExpr(c, e1, e2);
			}
			case 102: // unary_expression = PLUS.PLUS unary_expression.e
			{
					final Symbol PLUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new PlusExpr(e);
			}
			case 103: // unary_expression = MINUS.MINUS unary_expression.e
			{
					final Symbol MINUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new MinusExpr(e);
			}
			case 105: // preincrement_expression = PLUSPLUS.PLUSPLUS unary_expression.e
			{
					final Symbol PLUSPLUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new PreIncExpr(e);
			}
			case 106: // predecrement_expression = MINUSMINUS.MINUSMINUS unary_expression.e
			{
					final Symbol MINUSMINUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new PreDecExpr(e);
			}
			case 108: // unary_expression_not_plus_minus = COMP.COMP unary_expression.e
			{
					final Symbol COMP = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new BitNotExpr(e);
			}
			case 109: // unary_expression_not_plus_minus = NOT.NOT unary_expression.e
			{
					final Symbol NOT = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new LogNotExpr(e);
			}
			case 110: // for_init_opt = 
			{
					 return new List();
			}
			case 111: // for_init_opt = for_init.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 112: // for_update_opt = 
			{
					 return new List();
			}
			case 113: // for_update_opt = for_update.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 114: // block_statements_opt = 
			{
					 return new List();
			}
			case 115: // block_statements_opt = block_statements.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 116: // expression_opt = 
			{
					 return new Opt();
			}
			case 117: // expression_opt = expression.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Expr n = (Expr) _symbol_n.value;
					 return new Opt(n);
			}
			case 11: // statement = labeled_statement.labeled_statement
			case 12: // statement = if_then_else_statement.if_then_else_statement
			case 13: // statement = while_statement.while_statement
			case 14: // statement = for_statement.for_statement
			case 15: // statement = expression_statement.expression_statement
			case 16: // statement = block.block
			case 17: // statement = empty_statement.empty_statement
			case 18: // statement = do_statement.do_statement
			case 19: // statement = break_statement.break_statement
			case 20: // statement = continue_statement.continue_statement
			case 21: // statement = local_variable_declaration_statement.local_variable_declaration_statement
			case 22: // statement = goto_statement.goto_statement
			case 24: // for_init = statement_expression_list.statement_expression_list
			case 25: // for_update = statement_expression_list.statement_expression_list
			case 42: // expression = assignment_expression.assignment_expression
			case 43: // assignment_expression = conditional_expression.conditional_expression
			case 44: // assignment_expression = assignment.assignment
			case 56: // postfix_expression = literal.literal
			case 57: // postfix_expression = name.name
			case 58: // postfix_expression = postincrement_expression.postincrement_expression
			case 59: // postfix_expression = postdecrement_expression.postdecrement_expression
			case 68: // name = simple_name.simple_name
			case 70: // multiplicative_expression = unary_expression.unary_expression
			case 74: // additive_expression = multiplicative_expression.multiplicative_expression
			case 77: // shift_expression = additive_expression.additive_expression
			case 80: // relational_expression = shift_expression.shift_expression
			case 85: // equality_expression = relational_expression.relational_expression
			case 88: // and_expression = equality_expression.equality_expression
			case 90: // exclusive_or_expression = and_expression.and_expression
			case 92: // inclusive_or_expression = exclusive_or_expression.exclusive_or_expression
			case 94: // conditional_and_expression = inclusive_or_expression.inclusive_or_expression
			case 96: // conditional_or_expression = conditional_and_expression.conditional_and_expression
			case 98: // conditional_expression = conditional_or_expression.conditional_or_expression
			case 100: // unary_expression = preincrement_expression.preincrement_expression
			case 101: // unary_expression = predecrement_expression.predecrement_expression
			case 104: // unary_expression = unary_expression_not_plus_minus.unary_expression_not_plus_minus
			case 107: // unary_expression_not_plus_minus = postfix_expression.postfix_expression
			{
				return _symbols[offset + 1];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
