%header {: // Generated from parser/picoC.parser
package AST;
import AST.*; :};
%embed {: // Generated from parser/picoC.parser
int l = 1; // l means label :};
%left LPAREN, RPAREN, POSTINCDEC;
%right PLUSPLUS, MINUSMINUS, NOT, COMP, UNARY;
%left MULT, DIV, MOD;
%left PLUS, MINUS;
%left LSHIFT, RSHIFT;
%left LT, GT, LTEQ, GTEQ;
%left EQEQ, NOTEQ;
%left AND;
%left XOR;
%left OR;
%left ANDAND;
%left OROR;
%right QUESTION, COLON;
%right EQ, PLUSEQ, MINUSEQ, MULTEQ, DIVEQ, MODEQ, ANDEQ, XOREQ, OREQ, LSHIFTEQ, RSHIFTEQ;
%nonassoc BOTTOM;
%terminals LBRACE;
%terminals RBRACE;
%terminals SEMICOLON;
%terminals IDENTIFIER;
%terminals BYTE;
%terminals SHORT;
%terminals INT;
%terminals LONG;
%terminals CHAR;
%terminals FOR;
%terminals LPAREN;
%terminals RPAREN;
%terminals COMMA;
%terminals WHILE;
%terminals IF;
%terminals ELSE;
%terminals COLON;
%terminals GOTO;
%terminals CONTINUE;
%terminals BREAK;
%terminals DO;
%terminals EQ;
%terminals MULTEQ;
%terminals DIVEQ;
%terminals MODEQ;
%terminals PLUSEQ;
%terminals MINUSEQ;
%terminals LSHIFTEQ;
%terminals RSHIFTEQ;
%terminals ANDEQ;
%terminals XOREQ;
%terminals OREQ;
%terminals INTEGER_LITERAL;
%terminals LONG_LITERAL;
%terminals FLOATING_POINT_LITERAL;
%terminals DOUBLE_LITERAL;
%terminals CHARACTER_LITERAL;
%terminals STRING_LITERAL;
%terminals PLUSPLUS;
%terminals MINUSMINUS;
%terminals MULT;
%terminals DIV;
%terminals MOD;
%terminals PLUS;
%terminals MINUS;
%terminals LSHIFT;
%terminals RSHIFT;
%terminals LT;
%terminals GT;
%terminals LTEQ;
%terminals GTEQ;
%terminals EQEQ;
%terminals NOTEQ;
%terminals AND;
%terminals XOR;
%terminals OR;
%terminals ANDAND;
%terminals OROR;
%terminals QUESTION;
%terminals COMP;
%terminals NOT;
%typeof equality_expression = "Expr";
%typeof local_variable_declaration = "VarDeclStmt";
%typeof continue_statement = "ContinueStmt";
%typeof for_init = "List";
%typeof for_init_opt = "List";
%typeof postfix_expression = "Expr";
%typeof type = "Access";
%typeof unary_expression = "Expr";
%typeof inclusive_or_expression = "Expr";
%typeof literal = "Expr";
%typeof predecrement_expression = "Expr";
%typeof conditional_and_expression = "Expr";
%typeof simple_name = "Access";
%typeof postdecrement_expression = "Expr";
%typeof and_expression = "Expr";
%typeof conditional_expression = "Expr";
%typeof preincrement_expression = "Expr";
%typeof unary_expression_not_plus_minus = "Expr";
%typeof statement = "Stmt";
%typeof additive_expression = "Expr";
%typeof block = "Block";
%typeof for_update = "List";
%typeof for_update_opt = "List";
%typeof while_statement = "WhileStmt";
%typeof labeled_statement = "LabeledStmt";
%typeof shift_expression = "Expr";
%typeof block_statements = "List";
%typeof block_statements_opt = "List";
%typeof block_statement = "Stmt";
%typeof multiplicative_expression = "Expr";
%typeof statement_expression_list = "List";
%typeof if_then_else_statement = "IfStmt";
%typeof empty_statement = "EmptyStmt";
%typeof postincrement_expression = "Expr";
%typeof goal = "Program";
%typeof expression = "Expr";
%typeof expression_opt = "Opt";
%typeof assignment = "Expr";
%typeof expression_statement = "ExprStmt";
%typeof assignment_expression = "Expr";
%typeof statement_expression = "ExprStmt";
%typeof local_variable_declaration_statement = "VarDeclStmt";
%typeof exclusive_or_expression = "Expr";
%typeof for_statement = "ForStmt";
%typeof name = "Access";
%typeof conditional_or_expression = "Expr";
%typeof relational_expression = "Expr";
%typeof break_statement = "BreakStmt";
%typeof do_statement = "DoStmt";
%typeof goto_statement = "GotoStmt";
%goal goal;
goal =
    statement.statement {: return new Program(statement); :}
  ;
block =
    LBRACE.LBRACE block_statements_opt.list RBRACE.RBRACE {: return new Block(l++, list); :}
  ;
block_statements =
    block_statement.b {: return new List().add(b); :}

  | block_statements.l block_statement.b {: return l.add(b); :}
  ;
block_statement =
    statement.statement   ;
local_variable_declaration_statement =
    local_variable_declaration.l SEMICOLON.SEMICOLON {: return l; :}
  ;
local_variable_declaration =
    type.t IDENTIFIER.IDENTIFIER {: return new VarDeclStmt(l++, t, IDENTIFIER); :}
  ;
type =
    BYTE.BYTE {: return new PrimitiveTypeAccess("byte"); :}

  | SHORT.SHORT {: return new PrimitiveTypeAccess("short"); :}

  | INT.INT {: return new PrimitiveTypeAccess("int"); :}

  | LONG.LONG {: return new PrimitiveTypeAccess("long"); :}

  | CHAR.CHAR {: return new PrimitiveTypeAccess("char"); :}
  ;
statement =
    labeled_statement.labeled_statement 
  | if_then_else_statement.if_then_else_statement 
  | while_statement.while_statement 
  | for_statement.for_statement 
  | expression_statement.expression_statement 
  | block.block 
  | empty_statement.empty_statement 
  | do_statement.do_statement 
  | break_statement.break_statement 
  | continue_statement.continue_statement 
  | local_variable_declaration_statement.local_variable_declaration_statement 
  | goto_statement.goto_statement   ;
for_statement =
    FOR.FOR LPAREN.LPAREN for_init_opt.i SEMICOLON.SEMICOLON expression_opt.e SEMICOLON.SEMICOLON_ for_update_opt.u RPAREN.RPAREN statement.s {: return new ForStmt(l++, i, e, u, s); :}
  ;
for_init =
    statement_expression_list.statement_expression_list   ;
for_update =
    statement_expression_list.statement_expression_list   ;
statement_expression_list =
    statement_expression.e {: return new List().add(e); :}

  | statement_expression_list.l COMMA.COMMA statement_expression.e {: return l.add(e); :}
  ;
statement_expression =
    assignment.a {: return new ExprStmt(l++, a); :}

  | preincrement_expression.e {: return new ExprStmt(l++, e); :}

  | predecrement_expression.e {: return new ExprStmt(l++, e); :}

  | postincrement_expression.e {: return new ExprStmt(l++, e); :}

  | postdecrement_expression.e {: return new ExprStmt(l++, e); :}
  ;
while_statement =
    WHILE.WHILE LPAREN.LPAREN expression.e RPAREN.RPAREN statement.s {: return new WhileStmt(l++, e, s); :}
  ;
if_then_else_statement =
    IF.IF LPAREN.LPAREN expression.e RPAREN.RPAREN statement.t ELSE.ELSE statement.els {: return new IfStmt(l++, e, t, els); :}
  ;
labeled_statement =
    IDENTIFIER.id COLON.COLON statement.s {: return new LabeledStmt(l++, ((String)id.value), s); :}
  ;
goto_statement =
    GOTO.GOTO IDENTIFIER.id SEMICOLON.SEMICOLON {: return new GotoStmt(l++, ((String)id.value)); :}
  ;
continue_statement =
    CONTINUE.CONTINUE IDENTIFIER.id SEMICOLON.SEMICOLON {: return new ContinueStmt(l++, ((String)id.value)); :}

  | CONTINUE.CONTINUE SEMICOLON.SEMICOLON {: return new ContinueStmt(l++, ""); :}
  ;
break_statement =
    BREAK.BREAK IDENTIFIER.id SEMICOLON.SEMICOLON {: return new BreakStmt(l++, ((String)id.value)); :}

  | BREAK.BREAK SEMICOLON.SEMICOLON {: return new BreakStmt(l++, ""); :}
  ;
do_statement =
    DO.DO statement.s WHILE.WHILE LPAREN.LPAREN expression.e RPAREN.RPAREN SEMICOLON.SEMICOLON {: return new DoStmt(l++, s, e); :}
  ;
expression_statement =
    statement_expression.e SEMICOLON.SEMICOLON {: return e; :}
  ;
empty_statement =
    SEMICOLON.SEMICOLON {: return new EmptyStmt(l++); :}
  ;
expression =
    assignment_expression.assignment_expression   ;
assignment_expression =
    conditional_expression.conditional_expression 
  | assignment.assignment   ;
assignment =
    postfix_expression.dest EQ.EQ assignment_expression.source {: return new AssignSimpleExpr(dest, source); :}

  | postfix_expression.dest MULTEQ.MULTEQ assignment_expression.source {: return new AssignMulExpr(dest, source); :}

  | postfix_expression.dest DIVEQ.DIVEQ assignment_expression.source {: return new AssignDivExpr(dest, source); :}

  | postfix_expression.dest MODEQ.MODEQ assignment_expression.source {: return new AssignModExpr(dest, source); :}

  | postfix_expression.dest PLUSEQ.PLUSEQ assignment_expression.source {: return new AssignPlusExpr(dest, source); :}

  | postfix_expression.dest MINUSEQ.MINUSEQ assignment_expression.source {: return new AssignMinusExpr(dest, source); :}

  | postfix_expression.dest LSHIFTEQ.LSHIFTEQ assignment_expression.source {: return new AssignLShiftExpr(dest, source); :}

  | postfix_expression.dest RSHIFTEQ.RSHIFTEQ assignment_expression.source {: return new AssignRShiftExpr(dest, source); :}

  | postfix_expression.dest ANDEQ.ANDEQ assignment_expression.source {: return new AssignAndExpr(dest, source); :}

  | postfix_expression.dest XOREQ.XOREQ assignment_expression.source {: return new AssignXorExpr(dest, source); :}

  | postfix_expression.dest OREQ.OREQ assignment_expression.source {: return new AssignOrExpr(dest, source); :}
  ;
postfix_expression =
    literal.literal @ BOTTOM 
  | name.name @ BOTTOM 
  | postincrement_expression.postincrement_expression 
  | postdecrement_expression.postdecrement_expression   ;
literal =
    INTEGER_LITERAL.INTEGER_LITERAL {: return new IntegerLiteral(INTEGER_LITERAL); :}

  | LONG_LITERAL.LONG_LITERAL {: return new LongLiteral(LONG_LITERAL); :}

  | FLOATING_POINT_LITERAL.FLOATING_POINT_LITERAL {: return new FloatingPointLiteral(FLOATING_POINT_LITERAL); :}

  | DOUBLE_LITERAL.DOUBLE_LITERAL {: return new DoubleLiteral(DOUBLE_LITERAL); :}

  | CHARACTER_LITERAL.CHARACTER_LITERAL {: return new CharacterLiteral(CHARACTER_LITERAL); :}

  | STRING_LITERAL.STRING_LITERAL {: return new StringLiteral(STRING_LITERAL); :}
  ;
postincrement_expression =
    postfix_expression.e PLUSPLUS.PLUSPLUS @ POSTINCDEC {: return new PostIncExpr(e); :}
  ;
postdecrement_expression =
    postfix_expression.e MINUSMINUS.MINUSMINUS @ POSTINCDEC {: return new PostDecExpr(e); :}
  ;
name =
    simple_name.simple_name   ;
simple_name =
    IDENTIFIER.IDENTIFIER {: return new ParseName(IDENTIFIER); :}
  ;
multiplicative_expression =
    unary_expression.unary_expression 
  | multiplicative_expression.e1 MULT.MULT unary_expression.e2 {: return new MulExpr(e1, e2); :}

  | multiplicative_expression.e1 DIV.DIV unary_expression.e2 {: return new DivExpr(e1, e2); :}

  | multiplicative_expression.e1 MOD.MOD unary_expression.e2 {: return new ModExpr(e1, e2); :}
  ;
additive_expression =
    multiplicative_expression.multiplicative_expression @ BOTTOM 
  | additive_expression.e1 PLUS.PLUS multiplicative_expression.e2 {: return new AddExpr(e1, e2); :}

  | additive_expression.e1 MINUS.MINUS multiplicative_expression.e2 {: return new SubExpr(e1, e2); :}
  ;
shift_expression =
    additive_expression.additive_expression @ BOTTOM 
  | shift_expression.e1 LSHIFT.LSHIFT additive_expression.e2 {: return new LShiftExpr(e1, e2); :}

  | shift_expression.e1 RSHIFT.RSHIFT additive_expression.e2 {: return new RShiftExpr(e1, e2); :}
  ;
relational_expression =
    shift_expression.shift_expression 
  | relational_expression.e1 LT.LT shift_expression.e2 {: return new LTExpr(e1, e2); :}

  | relational_expression.e1 GT.GT shift_expression.e2 {: return new GTExpr(e1, e2); :}

  | relational_expression.e1 LTEQ.LTEQ shift_expression.e2 {: return new LEExpr(e1, e2); :}

  | relational_expression.e1 GTEQ.GTEQ shift_expression.e2 {: return new GEExpr(e1, e2); :}
  ;
equality_expression =
    relational_expression.relational_expression 
  | equality_expression.e1 EQEQ.EQEQ relational_expression.e2 {: return new EQExpr(e1, e2); :}

  | equality_expression.e1 NOTEQ.NOTEQ relational_expression.e2 {: return new NEExpr(e1, e2); :}
  ;
and_expression =
    equality_expression.equality_expression @ BOTTOM 
  | and_expression.e1 AND.AND equality_expression.e2 {: return new AndBitwiseExpr(e1, e2); :}
  ;
exclusive_or_expression =
    and_expression.and_expression @ BOTTOM 
  | exclusive_or_expression.e1 XOR.XOR and_expression.e2 {: return new XorBitwiseExpr(e1, e2); :}
  ;
inclusive_or_expression =
    exclusive_or_expression.exclusive_or_expression @ BOTTOM 
  | inclusive_or_expression.e1 OR.OR exclusive_or_expression.e2 {: return new OrBitwiseExpr(e1, e2); :}
  ;
conditional_and_expression =
    inclusive_or_expression.inclusive_or_expression @ BOTTOM 
  | conditional_and_expression.e1 ANDAND.ANDAND inclusive_or_expression.e2 {: return new AndLogicalExpr(e1, e2); :}
  ;
conditional_or_expression =
    conditional_and_expression.conditional_and_expression @ BOTTOM 
  | conditional_or_expression.e1 OROR.OROR conditional_and_expression.e2 {: return new OrLogicalExpr(e1, e2); :}
  ;
conditional_expression =
    conditional_or_expression.conditional_or_expression @ BOTTOM 
  | conditional_or_expression.c QUESTION.QUESTION expression.e1 COLON.COLON conditional_expression.e2 {: return new ConditionalExpr(c, e1, e2); :}
  ;
unary_expression =
    preincrement_expression.preincrement_expression 
  | predecrement_expression.predecrement_expression 
  | PLUS.PLUS unary_expression.e @ UNARY {: return new PlusExpr(e); :}

  | MINUS.MINUS unary_expression.e @ UNARY {: return new MinusExpr(e); :}

  | unary_expression_not_plus_minus.unary_expression_not_plus_minus   ;
preincrement_expression =
    PLUSPLUS.PLUSPLUS unary_expression.e {: return new PreIncExpr(e); :}
  ;
predecrement_expression =
    MINUSMINUS.MINUSMINUS unary_expression.e {: return new PreDecExpr(e); :}
  ;
unary_expression_not_plus_minus =
    postfix_expression.postfix_expression @ BOTTOM 
  | COMP.COMP unary_expression.e {: return new BitNotExpr(e); :}

  | NOT.NOT unary_expression.e {: return new LogNotExpr(e); :}
  ;
for_init_opt =
	 {: return new List(); :}
  | for_init.n
	 {: return n; :}
  ;
for_update_opt =
	 {: return new List(); :}
  | for_update.n
	 {: return n; :}
  ;
block_statements_opt =
	 {: return new List(); :}
  | block_statements.n
	 {: return n; :}
  ;
expression_opt =
	 {: return new Opt(); :}
  | expression.n
	 {: return new Opt(n); :}
  ;
